

              ===============================================
              Release notes for the Genode OS Framework 15.08
              ===============================================

                               Genode Labs



;intro
;@nfeske


Genode on top of the Muen separation kernel
###########################################

_This section was written by Adrian-Ken Rueegsegger and Reto Buerki who_
_conducted the described line of work independent from Genode Labs._

After completing our x86_64 port of the Genode base-hw kernel, which was
featured in the previous release (15.05), we immediately started working on our
main goal: running a Genode system as guest on the Muen Separation Kernel (SK)
to benefit from the rich ecosystem of Genode.

For those who have not read the 15.05 Genode release notes, [http://muen.sk - Muen]
is an Open-Source microkernel, which uses the [http://spark-2014.org/ - SPARK]
programming language to enable light-weight formal methods for high assurance.
The 64-bit x86 kernel, currently consisting of a little over 5'000 LOC, makes
extensive use of the latest Intel virtualization features and has been formally
proven to contain no runtime errors at the source-code level.

The new 'hw_x86_64_muen' platform, as the name implies, extends the 'hw_x86_64'
base-hw kernel by replacing the PIC and timer drivers with paravirtualized
variants.

In contrast to other kernels supported by Genode, the architecture with Muen is
different in the sense that the entire 'hw_x86_64_muen' Genode system runs as
guest VM in VMX non-root mode on the SK. From the perspective of Muen, Genode
is executed on top of the kernel like any other guest OS without special
privileges.

[image muen_system_overview]
  Genode running on top of the Muen Separation Kernel alongside other subjects

This loose coupling of Muen and Genode base-hw enables the robust combination
of a static, low-complexity SK with a feature-rich and extensive OS framework.
The result is a flexible platform for the construction of component-based
high-assurance systems.

People interested in giving the 'hw_x86_64_muen' platform a spin can find a
small tutorial at _repos/base-hw/doc/x86_64_muen.txt_.


NOVA kernel-resource management
###############################

The NOVA kernel serves Genode on x86 as a main platform since the last years,
mainly because of two reasons. On the one hand the kernel provides, among the
supported x86 kernels, the richest hardware feature set like the support of
IOMMUs, virtualization and SMP. On the other hand the design of the
kernel, the stable kernel interface, the available kernel interface
specification, the readable and modern source base is a pleasure to work with.
Because of all the reasons Genode Labs is and was able to maintain and extend
the kernel.

Nevertheless the vanilla kernel lacks one essential feature since the beginning
to reliable host Genode as user-land, namely the kernel memory management. In
the past we extended the kernel already to free up kernel resources when they
get destructed, e.g. processes and the page-tables, threads, semaphores and
portals.

Still, on Genode/NOVA a process may trigger arbitrary kernel memory consumption
during RPC by delegating memory or capabilities or by creating processes and
threds via Genode's core. If the kernel memory gets depleted, the kernel panics
with a "Out of memory" message and the overall Genode scenario stops.

The consumption can be in principal triggered by any deliberately misbehaving
respectively greedy process. Unfortunately this happens normal day-to-day
usage of Genode, e.g. compiling and linking source code in Genode's Noux
environment. Our nightly test compiling Genode in Noux on Genode/NOVA already
triggers this from time to time.

The main issue here is that the kernel memory consumption are not and can not
be accounted and limited by Genode, because the kernel interface does not
support such a feature. Kernels like seL4 as Genode's own base-hw kernel shows
how this can be solved.

To improve the current situation - where the overall kernel memory amount is
fixed - we extended the kernel during the last release in the following ways.

First - the NOVA kernel accounts any kernel memory consumption per process.
Second - every process has a limited amount of kernel memory quota it can use.
Third - the kernel detects when the quota limit of a process is reached.

The kernel may notify another thread (if configured so) about this situation,
otherwise the thread causing the situation gets stopped.
The so called - out-of-memory(OOM) - handler thread gets information about the
situation and may react on it. Possible reactions can be for example to:

- either stop the thread of the process or
- transfer kernel memory quota between processes (upgrading the limit if desired) or
- free up kernel memory if possible, e.g. revoke memory delegations which can be re-created

The steps above we implemented in the NOVA kernel and extended Genode's core
to handle such OOM situations. All syscalls beside the IPC call/reply may
now return a error code which specifies that the quota was insufficient. These
syscalls are solely done and permitted by core and handled inside the base-nova
specific platform code.

In the case of IPC call/reply we wanted to handle OOM cases however
transparently to the Genode user applications. Therefore every thread in
Genode/NOVA now gets constructed with a OOM IPC-Portal attached. This portal
is served by the pager thread in core and gets called, when a OOM situation is
detected during IPC call/reply. If the pager thread receives such a OOM IPC,
it decodes the involved IPC sender and IPC receiver and looks up the
appropriate core internal Genode paging objects.

The current implemented out-of-memory policy of the OOM handling code of the
pager thread first tries to upgrade the quota. If this is not possible anymore
the second attempt is to revoke some user-memory of the OOM causing process
and therefore implicitly to free-up some kernel memory. If none of the
reactions succeeds the causing thread can be stopped by the pager.

The current policy implementation at the moment is a rather rough heuristic,
which does not suffice all needs. At this point one would like to specify per
process a policy, e.g. depending on the typical known memory usage pattern.
For example some processes should only have a static usage pattern, and
therefore a hard fixed upper quota limit. Other processes are highly dynamic
and there some quota upgrades to some degree are desired. There are a lot of
more combinations imaginable.

Our plan for now is to collect some experience over the next months with the
new kernel OOM mechanism. Based on the observations we may externalize such
policy decisions outside core and make it possibly configurable per Genode
process.

The current state of the integration of the extended NOVA kernel with core
however already avoids the situation that the whole kernel goes out-of-service
if a process behaves kernel-memory-wise greedy.


Genode as day-to-day operating system
#####################################

At the beginning of June, Genode reached the most symbolic milestone in
the project's history: Norman - one of Genode's core developers - replaced
his Linux-based working environment with a Genode-based system. This system
has the ingredients:

[image turmvilla_scenario]

The used machine is a Lenovo Thinkpad x201. We picked this five year old machine
for several reasons. First, it is a very solid platform with a nice form
factor. Second, it features Intel's AMT (Active Management Technology),
which is handy to obtain low-level system logs in the case something
goes wrong. Third, refurbished machines of this type can be obtained for
as little as 200 EUR. Finally, an older machine reinforces the need for good
performance of the operating system. So it creates a natural incentive
for Norman to find and address performance bottlenecks.

Our modified version of the NOVA microhypervisor is used the kernel.

The user interface is based on our custom GUI stack including the
nitpicker GUI server as well as the window manager and its companion
components (decorator, layouter, pointer).
The display is driven by the VESA driver.
User input is handled by the PS/2 driver for handling the laptop keyboard
and trackpoint, and the USB driver for handling an externally connected
keyboard and mouse.

Network connectivity is provided by our port of the Intel Wireless stack that
we introduced with the version
[http://genode.org/documentation/release-notes/14.11#Intel_wireless_stack - 14.11].

Our custom AHCI driver provides access to the physical hard disk. File-system
access is provided by our Rump-kernel-based file-system server.

A simple Genode shell called CLI monitor allows the user to start and kill
subsystems dynamically. The most important two subsystems are VirtualBox and
Noux.

VirtualBox executes a GNU/Linux-based guest OS that we call "Rich OS". The
rich OS serves as a migration path from GNU/Linux to Genode. It is used for
all tasks that cannot be accommodated directly on Genode yet. At the beginning
of the transition, the daily work flows still very much depend on the Rich OS.
But by moving more and more functionality over to the Genode world, we will
eventually be able to make the Rich OS obsolete step by step.
Thanks to VirtualBox' excellent host-guest-integration features, the
VirtualBox window can dynamically resized and the guest mouse cursor
integrates seamlessly with Genode's pointer. VirtualBox is directly connected
to the wireless network driver.

The noux runtime allows us to use command-line-based GNU software directly on
Genode. Coreutils and Bash are used for managing files. Vim is used for
editing files. Unlike the rich OS, the noux environment has access to the
Genode partition of the hard disk. In particular, it can be used to update the
Genode sustem. It has access to a number of pseudo files that containing
status information of the underlying components, e.g., the list of wireless
access points. Furthermore, it has limited access to the configuration
interfaces of the base components. For example, it can point the wireless
driver to the accesspoint to use, or change the configuration of the nitpicker
GUI server at runtime.

As a bridge between the rich OS and the Genode world, we combine VirtualBox'
shared folder mechanism with Genode VFS infrastructure. The shared
folder is represented by a dedicated instance of a RAM file system, which
is mounted in both the VFS of VirtualBox and the VFS of noux.

As evidenced by Norman's use since June, the described system setup is
sufficient to be productive. So other members of the Genode team will follow
his footsteps soon. At the same time, the continued use of the system from day
to day revealed a number of shortcomings, performance limitations, and rough
edges, which we eventually eliminated. It goes without saying that this is an
ongoing effort. Eating our own dog food forces us to address the right issues
to make the daily life more comfortable.

Feature-wise the switch to Genode motivated three developments, namely the
enhancement of Genode's CLI monitor, the improvement of the window manager,
and the creation of a CPU-load monitor tool.


Interactive management of subsystem configurations
==================================================

The original version of CLI monitor obtained the configuration data of
its subsystems only at start time via the Genode::config mechanism.
But for managing complex scenarios, the config
node becomes very complex. Hence, it is preferable to have a distinct
file for each subsystem configuration.

The new version of CLI monitor scans the directory '/subsystems' for files ending with
".subsystem". Each file has the same syntax as the formerly used
subsystem nodes. This change has the welcome implication that subsystem
configurations can be changed during the runtime of the CLI monitor, e.g.,
by using a concurrently running instance of noux with access to the
_subsystems/_ directory. This procedure has become an essential part
of the daily workflow as it enables the interactive evolution of the
Genode system.


Window-management improvements
==============================

To make the window manager more flexible while reducing its complexity
at the same time, we removed the formerly built-in policy of the
decorator and layout components. Those components are no longer
child components of the window manager but siblings. The relationship
of the components is expressed by the configuration of their common
parent, i.e., init.

For improving the usability of the windowed GUI, we enabled the layouter to
raise windows on click and to let the keyboard focus follow the pointer.
Furthermore, the window manager, the decorator, and the floating window
layouter became able to propagate the usage of an alpha channel from the
client application to the decorator. This way, the decorator can paint the
decoration elements behind the affected windows, which would otherwise be
skipped.


CPU load monitoring
===================

During the daily use of the system, we wished to know in detail where the
CPU cycles are spent. For example, the access of a file by the rich OS
involves several components including the guest OS itself, VirtualBox,
rump_fs (file-system), part_blk (partition access), ahci_drv (SATA device
access), core, and NOVA. Investigating performance issues requires a
holistic view of all those components. For this reason, we enhanced our
existing tracing infrastructure (Section [Enhanced tracing facilities])
to allow the creation of CPU-load monitoring tools. The first tool in
this category is the graphical CPU-load monitor located at
_gems/app/cpu_load_display/_, which displays a timeline of the CPU load
where each thread is depicted with a different color. Thanks to this
tool, we have become to explore performance issues in an interactive
way. In particular, it helped us to identify and resolve a long-standing
inaccuracy problem of our low-level timer service.


Base framework and low-level OS infrastructure
##############################################

Improved audio support
======================

In the previous release we replaced the old audio driver with a new one
that also provided the Audio_out service. In line with the Audio_out
session we are now introducing a new Audio_in session interface that can be
used to record audio frames. It is modelled after the Audio_out interface in
the way how it handles the communication between the client and the server.
It also uses shared memory in form of the Audio_in::Stream to transport the
frames between them. A server component captures frames and puts them into a
packet queue, which is embedded in the Audio_in::Stream. The server allocates
packets from this queue to store the recorded audio frames. If the queue is
already full, the server will override already allocated packets and will notify
the client by submitting the 'overrun' signal. The client has to cope with this
situation, e.g., by saving packets more frequently. A client can install a
signal handler to react on the 'progress' signal, which is send by the server
when a new Audio_in::Packet was submitted to the packet queue. For now all
Audio_in server components only support one channel (left) although the
Audio_in session interface itself supports multiple channels.

The dde_bsd audio_drv is the first and currently only audio driver component
that was extended to provide the Audio_in session. To express this fact the
driver was renamed from 'audio_out_drv' to 'audio_drv'. In contrast to its
playback functionality, which is enabled by default, recording has to be enabled
explicitly by setting the configuration attribute 'recording' to 'yes'. If the
need arises playback may be disabled by setting 'playback' to 'no'. In addition,
it is now possible to configure the driver by adjusting the mixer in the
drivers configuration node. For the time being, the interface as employed by
the original OpenBSD mixer utility is used.

The following snippet shows how to enable and configure recording on an
Thinkpad X220 where the headset instead of the internal mic is used as
source:

! <start name="audio_out_drv">
!   <resource name="RAM" quantum="8M"/>
!   <provides>
!     <service name="Audio_out"/>
!     <service name="Audio_in"/>
!   </provides>
!   <config recording="yes">
!     <mixer field="outputs.master" value="255"/>
!     <mixer field="record.adc-0:1_source" value="sel2"/>
!     <mixer field="record.adc-0:1" value="255"/>
!   </config>
! </start>

In addition to selecting the recording source the playback as well as the
recording volume are raised to the maximum. Information about all available
mixers and settings in general may be obtained by specifying the 'verbose'
attribute in the config node.

The enriched driver is accompanied by a simple monitor application, which
directly plays all recorded audio frames back and shows how to use the
Audio_in session. It can be tested by executing the
_repos/dde_bsd/run/audio_in.run_ run script.

There are also changes to the Audio_out session itself. The length of a period
was reduced from 2048 to 512 samples to accommodate for a lower latency when
mixing Audio_out packets and a method for invalidating all packets in the
queue queue was added.


File-system infrastructure
==========================

;@nfeske

commit e3be65833f8db26de47fa86e63fa1d5fcef07e47
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Nov 26 18:07:03 2014 +0100

    vfs: decouple file-system factory from libc
    
    This patch moves the VFS file-system factory to a separate vfs library
    that is independent from libc. This enables libc-less Genode programs to
    easily use the VFS infrastructure.
    
    Fixes #1561

commit af5c03edaf3db9e8444cad9c7ede1dbb70cc1d1b
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Mon Jul 6 12:11:30 2015 +0200

    vfs: depend on ld library
    
    So, users of VFS need not to state this dependency explicitly.


commit cec2dd3b3fc1ec0d494f48448b64345b92aee65a
Author: Emery Hemingway <emery@vfemail.net>
Date:   Thu Jun 4 08:59:40 2015 -0400

    unify file system utilities to os/include/file_system
    
    Fixes #1564


commit 2f1db06debc37587c1669d388afd32d8efc6514a
Author: Emery Hemingway <emery@vfemail.net>
Date:   Sat Jun 27 15:50:49 2015 -0500

    rump_fs/fuse_fs/lx_fs/ram_fs: symlink fixup
    
    Allow symlinks to be passed to the read and write file system utilities.
    
    Disallow writes to symlinks with offsets in file system servers, this is
    to ensure that writing the target of a symlink is an atomic operation.
    
    Fixes #1604

commit 8f4f1ae89c6b79016a1d6e931d4fd1168c5531ad
Author: Emery Hemingway <emery@vfemail.net>
Date:   Tue Jul 7 15:45:37 2015 -0500

    ram_fs: treat symlinks as opaque data
    
    Fixes #1604

commit f996697fd53b27f774f9688d37f6edb3ffe5ffd6
Author: Emery Hemingway <emery@vfemail.net>
Date:   Wed Jul 22 00:32:42 2015 -0500

    VFS: local ram_fs instances
    
    Move FS Node implementations from server/ram_fs to include/ram_fs.
    Support embedded ram_fs instances in VFS configurations using <ram/>.
    Add 'no space' handling to VFS symlink ops.
    
    Fixes #1635

; proposal by emery:
;
;During different file system dependent experiments a need for private,
;temporary areas arose. This lead to a quick conversion of the ram_fs server
;core to an embeddable VFS file system. This addition to the set of VFS plugins
;allows processes to create, modify, and remove files without defining and
;allocating resources to an additional component. More embeddable versions of
;the dedicated file system servers can be expected in later releases as the use
;of the VFS evolves.


Unified networking components
=============================

Having had a good experience with our Block::Driver implementation, which wraps
the block-session interface and takes care of the packet stream handling, thus
easing the implementation of driver and other block components, we observed that
this approach did not provide enough flexibility for NIC-session servers. For
example, NIC servers are two directional and when a network packet arrives the
server has to make sure that there are enough resources available to dispatch
the network packet to the client. This has to be done because the server cannot
wait for allocations or an empty spot in the packet queue of a client.
Therefore, the server wants to check these conditions before dispatching the
packet and if they cannot be met it will usually drop the network packet.

In order the implement this kind a behavior, NIC-session servers must have
direct access to the actual NIC session. For this reason, we removed the
Nic::Driver interface from Genode and added a Nic::Session_component that offers
some basic packet-stream-signal dispatch functionality. Servers may now inherit
from this component and implement there own policy.

We adjusted all servers that implement NIC sessions to the new interface
(dde_ipxe, wifi, usb, nic_bridge, OpenVPN, ...), and thus unified all networking
components within Genode.


Enhanced tracing facilities
===========================

;@nfeske

commit 959572968de0a932dd051a1a1f279061666a6217
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Thu Jun 11 23:05:02 2015 +0200

    core: provide thread exec times via TRACE service
    
    This patch enable clients of core's TRACE service to obtain the
    execution times of trace subjects (i.e., threads). The execution time is
    delivered as part of the 'Subject_info' structure.
    
    Right now, the feature is available solely on NOVA. On all other base
    platforms, the returned execution times are 0.
    
    Issue #813

commit b22f3c67f00b7620eb88968ad3550e2918ddcf25
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Mon Jun 15 20:41:59 2015 +0200

    Trace-subject reporter
    
    Issue #813

commit fbe44f08d47597b4e95897c51ebbd60e76419bf0
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Wed Dec 17 13:57:59 2014 +0100

    nova: support to read thread and idle time
    
    Issue #813

commit a23ac5f569998dce39a74145b64708df7347834e
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Tue Jun 16 20:39:09 2015 +0200

    base/nova: add idle threads to trace sources
    
    Issue #813

commit 5d678dba9edd6e45c5657b27a09b34592572ae6e
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Jun 17 13:25:51 2015 +0200

    core: throw Trace::Out_of_metadata in subjects()
    
    While importing trace sources as trace subjects into a TRACE session,
    the session quota might become depleted. The TRACE session already keeps
    track of the session quota via an allocator guard but the 'subjects' RPC
    function missed to handle the out-of-memory condition. This patch
    reflects the error condition as an 'Out_of_metadata' exception to the
    TRACE client. It also contains an extension of the trace test to
    exercise the corner case.

commit 7e40f5f587aab6aca1daf6af00e43eb7e6790855
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Fri Jul 3 16:22:35 2015 +0200

    base: use proper Cpu_session when tracing threads
    
    Up to now it was not possible to trace threads that use a different
    Cpu_session rather than env()->cpu_session() (as done by VirtualBox).
    This problem is now solved by setting the Cpu_session explicitly when
    creating the event logger and attaching the trace control area when
    creating the thread.
    
    Fixes #1618.


Low-complexity software rendering functions
===========================================

Our ambition to use Genode as our day-to-day OS raises the need for custom
graphical applications. Granted, it is principally possible to base such
applications on Qt5, which is readily available to native Genode components.
But for certain applications like status displays, we prefer to avoid the
dependency on an overly complex GUI tool kit. To accommodate such
applications, Genode hosts a small collection of low-complexity graphics
functions called painters. All of Genode's low-complexity graphical components
such as nitpicker, launchpad, or the terminal are based on this
infrastructure.

With the current release, we extend the collection with two new painters
located at _gems/include/polygon_gfx_. Both draw convex polygons with an
arbitrary number of points. The shaded-polygon painter interpolates the color
and alpha values whereas the textured-polygon painter applies a texture to the
polygon. The painters are accompanied by simplistic 3D routines located at
_gems/include/nano3d/_ and a corresponding example (_gems/run/nano3d.run_).

[image nano3d]

With the nano3d demo and our new CPU load display, the screenshot above
shows two applications that make use of the new graphics operations.


Device drivers
##############

Completing the transition to the new platform driver
====================================================

Until now the ACPI and PCI driver form on x86 the platform driver, whereby
the ACPI driver started the PCI driver as slave service. The ACPI
driver parsed the ACPI tables and provided the relevant information as
configuration during PCI driver startup. We changed this close interaction
to the more modern and commonly used report_rom Genode mechanism.

When the new ACPI driver finishes the ACPI table parsing, it provides the 
information via a Genode report to any interested and registered component.
The PCI driver is such a component, which gets connected via the Genode
configuration as a consumer of the ACPI report. The report contains e.g.
the IRQ re-routing information.

With the change of the interaction of ACPI and PCI driver the policy for
devices must be configured solely with the PCI driver and not anymore with the
ACPI driver. The syntax, however, stayed the same as introduced with release
15.05.

Finally the PCI driver 'pci_drv' got renamed to 'platform_drv' as used on most
ARM platforms already. All files and session interfaces containing PCI/pci in
the names get renamed to PLATFORM/platform. The x86 platform interfaces now
reside in 'repos/os/include/platform/x86/' and the implementation of the
platform driver in 'repos/os/src/drivers/platform/x86/'.

A example x86 platform configuration snippet looks like this:

!<start name="acpi_drv" >
! <resource .../>
! <route>
!  ...
!  <service name="Report"> <child name="acpi_report_rom"/> </service>
! </route>
!</start>
!
!<start name="acpi_report_rom" >
! <binary name="report_rom"/>
! <resource .../>
! <provides> <service name="ROM" /> <service name="Report" /> </provides>
! <config>
!  <rom> <policy label="platform_drv -> acpi" report="acpi_drv -> acpi"/> </rom>
! </config>
! <route> ... </route>
!</start>
!
!<start name="platform_drv" >
! <resource name="RAM" quantum="3M" constrain_phys="yes"/>
! <provides> <service name="Platform"/> </provides>
! <route>
!  <service name="ROM">
!   <if-arg key="label" value="acpi"/> <child name="acpi_report_rom"/>
!  </service>
!  ...
! </route>
! <config>
!  <policy label="ps2_drv"> <device name="PS2"/> </policy>
!  <policy label="nic_drv"> <pci class="ETHERNET"/> </policy>
!  <policy label="fb_drv"> <pci class="VGA"/> </policy>
!  <policy label="wifi_drv"> <pci class="WIFI"/> </policy>
!  <policy label="usb_drv"> <pci class="USB"/> </policy>
!  <policy label="ahci_drv"> <pci class="AHCI"/> </policy>
!  <policy label="audio_drv"> <pci class="AUDIO"/> <pci class="HDAUDIO"/> </policy>
! </config>
!</start>

In order to unify and simplify the writing of test run scripts we added a
platform configuration to the file 'repos/base/run/platform_drv.inc'.
This may be included by any test run script in order to setup the platform
driver configuration.

The file provides the following functions: 'append_platform_drv_build_components',
'append_platform_drv_config', 'append_platform_drv_boot_modules'. The usage
of the functions add the necessary information to the 'build_components',
'config' and 'boot_modules' run variables. The platform_drv.inc takes also care
to distinguish between all the ARM/x86 platform and includes the necessary
pieces.

The body of a example run script looks like this:

! set build_components { ... }
!
! source ${genode_dir}/repos/base/run/platform_drv.inc
! append_platform_drv_build_components
!
! build $build_components
!
! create_boot_directory
!
! set config { ... }
!
! append_platform_drv_config
!
! append config { ... }
!
! install_config $config
!
! append_platform_drv_boot_modules
!
! build_boot_image $boot_modules
!
! run_genode_until ...


BCM57cxx network cards
======================

During Hack'n Hike 2015 we had access to a server that featured a Broadcom-
network card. Therefore Guido Witmond performed the first steps to enable
Broadcom's BCM 57cxx cards. With this preliminary work in place, we were quickly
able to perform the additional stops required to add BCM 57cxx support to
Genode.


VESA driver refinements
=======================

The VESA driver now reports the framebuffer width to the client instead of the
visible width. This fixes possible distortion if these widths differ, at the
cost that content in the right-most area might be invisible in such cases.


VirtualBox
##########

Policy-based mouse pointer
==========================

With the previous release, we implemented support for transparent
integration of the guest mouse pointer with Nitpicker via the
VirtualBox guest additions and the vbox_pointer component capable of
rendering provided mouse-pointer shapes. Now, we extended vbox_pointer
by policy-based configuration that allows the selection of ROMs
containing the actual mouse shape based on the Nitpicker session label
or domain. With this feature in place, it is possible to integrate
several VirtualBox instances as well as dedicated pointer shapes for
specific components. To see the improved vbox_pointer in action give
_run/vbox_pointer_ a shot.


Dynamic adaptation to screen size changes
=========================================

VirtualBox now notifies the guest operating system about screen size changes
(for example if the user resizes a window which shows the guest framebuffer).
The VirtualBox Guest Editions can use this information to adapt the guest
framebuffer to the new size.

SMP support
===========

Guest operating systems can now use multiple virtual CPUs, which are
mapped to multiple host CPUs. The number of virtual CPUs can be configured
in the '.vbox' file.

Preliminary audio support
=========================

At some point using VirtualBox as a stop-gap solution for using Genode as ones
every day OS also envolves having the ability to handle audio.
With this release we address this matter by enabling preliminary audio
support in our VirtualBox port. A backend that uses the Audio_out and
a Audio_in session to playback and record sound samples was added. It disguises
itself as the OSS backend, that is already used by vanilla VirtualBox. The
reason for doing so is the fact that we do not want to maintain more patches
than are absolutely necessary. Since we are already FreeBSD in the eyes of
VirtualBox it makes things easier to just provide an implementation of the OSS
backend because this is also used when using FreeBSD as host system.
The audio support is complemented by adding the necessary drivers for the HDA
as well as the AC97 device models to our VirtualBox port.

For now, it is vital to have the guest OS configure the device model in a way
that favors the current implementation. For example, the way our VirtualBox
port currently works we cannot guarantee distortion free playback or recording
if the guest OS uses a period that is two short, typically 10ms or less.
There are also some issues with the mixing/filtering code in VirtualBox.
Therefore, we bypass it to get better audio quality. As a consquence of that
the device model of the VM has to use the same sample rate as is used by the
Audio_out and Audio_in sessions (44.1kHz), however.

Enabling audio support is done be adding

! <AudioAdapter controller="HDA" driver="OSS" enabled="true"/>

to the .vbox file manually or configuring the VM accordingly by using the GUI.

The reason why we talk about preliminary support is the fact that the current
state is lacking in robustness and audio quality and we are still working on
improving it.


Platforms
#########

Execution on bare hardware (base-hw)
====================================


Bender chain loader on base-hw x86_64
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

On Intel platforms, we use the Bender chain loader from the
[https://github.com/alex-ab/morbo - Morbo multiboot suite] to detect
available COM ports of PCI plug-in cards, the AMT SOL device or as
fall back the default comport 1. The loader stores the I/O port
information of detected cards into the BIOS data area (BDA), from
where it is retrieved by core on boot and used for the log output.
With this release, we added the BDA parsing to base-hw on x86-64 and
enabled the feature in the run tool. As a prerequisite we had to fix
an issue in bender if only one (large) multi-boot kernel has to be
loaded and, therefore, updated its binary in _tool/boot/bender_.


Revised page-table handling
~~~~~~~~~~~~~~~~~~~~~~~~~~~
One of the main advantages of the base-hw platform is that the memory trading
concept of Genode is universally applied even regarding kernel objects. For
instance, whenever a component wants to create a thread, it pays for the
thread's stack, UTCB, and even for the corresponding kernel object. The same
applies to the objects needed to manage the virtual address space of a
component with the single exception of page-tables.

Normally, when the quota, which was donated by a component to a specific
service, runs out, the component receives an exception next time it tries
to invoke the service. Then it can upgrade its quota.
Within the context of page-fault resolution this is especially difficult to do.
The allocation and thereby the shortage of memory gets revealed when the client
is faulting. Therefore, it is difficult to inform the component to first
transmit more quota before resolving the fault.

Instead of designing a sophisticated protocol between core and the other
components to solve this problem, we decided to simplify the current page-fault
resolution by using a static set of page-tables per component. Formerly,
page-tables were dynamically allocated from core's memory allocator. Now,
an array of page-tables gets allocated during construction of a protection
domain. When a component runs out of page-tables, all it's mapping get flushed,
and the page-tables are populated from scratch. This change greatly simplifies
the page-table handling inside of base-hw.


Dynamic interrupt mode setting on x86_64
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

On x86-based hardware, user-level device drivers have become able to specify
the trigger mode and polarity of the interrupts when requesting an IRQ
session. On ARM, those session parameters are ignored. This change enables the
x86_64 platform to support devices which use arbitrary trigger modes and
polarity settings, e.g. AHCI on QEMU and real hardware.


Fiasco.OC
=========

Genode's device-driver support when using the Fiasco.OC kernel as base platform
received an upgrade.

First, principle support for the Raspberry Pi was added. To make this
platform useful in practice, a working USB driver is important. I.e., the
network interface is connected via USB. Hence the USB driver got enabled for
Fiasco.OC, too. As a result, Genode's software stack can now be used on the
Raspberry Pi by using either our custom base-hw kernel or Fiasco.OC.

Second, support for the Odroid-X2 platform using the Exynos4412 SoC was added,
which includes the drivers for the clock management (CMU), power management
(PMU) as well as USB.

Thanks to Reinier Millo Sánchez and Alexy Gallardo Segura for having
contributed this line of work.


Removal of deprecated features
##############################

We dropped the support for the *ARM Versatile Express* board from the Genode
source tree to relieve our automated testing infrastructure from supporting
a platform that remained unused for more than two years.

The device driver environment kit (DDE Kit) was originally intended as
a common API among the execution environments of ported user-level device drivers.
However, over the course of the past years, we found that this approach could
not fulfill this premise while introducing a number of new problems.
We reported our experiences in the release notes of versions
[http://genode.org/documentation/release-notes/12.05#Re-approaching_the_Linux_device-driver_environment - 12.05] and
http://genode.org/documentation/release-notes/14.11#Roundup - 14.11].
To be able to remove the DDE-Kit API, we reworked the USB driver, our port of
the Linux TCP/IP stack, and the wireless driver accordingly.

