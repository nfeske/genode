

              ===============================================
              Release notes for the Genode OS Framework 16.08
              ===============================================

                               Genode Labs



; intro
; @nfeske


Interactive and dynamic workloads on top of the seL4 kernel
###########################################################

seL4 is a modern microkernel that undergoes verification and promises to be
a well foundation for trustworthy systems. Genode, as operating system
framework, on top of a microkernel pursues goals of the same direction.
Therefore we added already basic Genode/seL4 platform support in the last
releases. Additionally Genode
contributes highly dynamic workloads to the seL4 community, which up to
now focuses on static loads. With over hundred ready-to-use
components, Genode provides a rich pool of building blocks, starting from
native device drivers, resource multiplexer, protocol stacks,
application frameworks (e.g. Qt) and applications (e.g. web browser Arora).

The experimental support, until now, was sufficient to showcase the potential
of the combination - admittedly mainly to technical enthusiasts. With this
release we rump up the platform support of Genode/seL4 to a degree that most
interactive and dynamic workloads of Genode can be executed.

With this release we updated to the seL4 version 3.2.0 and enabled all
available time-tested x86 Genode drivers for seL4. The main working items has
been the implementation of the IRQ session, IOPORT session, IOMEM session and
SIGNAL session support and the lifetime management (freeing) of resources
in core for seL4.

Finally we tested our setups on Qemu and on native x86 hardware and are
happy to report that the following drivers are available for Genode/seL4,
namely the PIT timer, PS/2, USB, AHCI, ACPI driver, VESA driver,
Audio driver, Intel Wifi card driver and Intel Graphics driver. All automated
test scenarios are now successfully executed nightly on Qemu and on native
hardware as done for all supported x86 kernels.

Minor adjustments and patches to the seL4 kernel have been necessary, which
we are contributing back to the seL4 kernel community currently. The changes
comprise device memory required by ACPI, VESA and Intel graphic, comprise
the IRQ IOAPIC handling and the syscall bindings. As Genode uses shared
libraries, the syscall bindings must be able to be compiled position
independent. The extension to read ot the I/O ports for the serial
cards via the BIOS data area already upstream on seL4.

Still, some working items for Genode/seL4 remain for the future, namely:
- message signaled interrupt (MSI) support
- multi processor support
- Genode capability integrity support
- incomplete Genode capability lifetime management, e.g. freeing of selectors
- thread priorities
- IOMMU support
- VirtualMachineMonitor (VMM) support

Additionally, some allocators for memory and capabilities in Genode/seL4 are
statically chosen which will not fit every x86 machine with lot of memory.

Virtual networking and transparent support for TOR
##################################################

; @skalk @mstein



VirtualBox on top of the Muen and NOVA kernels
##############################################


VirtualBox 4 on top of the Muen separation kernel
=================================================

Overview
~~~~~~~~

As briefly mentioned in the Genode
[https://genode.org/documentation/release-notes/16.05 - 16.05 release
notes], we have been working on VirtualBox support for 'hw_x68_64_muen'. The
implementation has finally reached a stage where all necessary features have
been realized and it has been integrated into Genode's mainline.  This means
that you can now run strongly isolated Windows VMs on the Muen separation
kernel providing an user experience that is on par with VirtualBox on NOVA.

Our initial plan when we started our work on Genode was to leverage its
VirtualBox support as a means to run Windows on Muen. As a first step we ported
the base-hw kernel, then ARM-only, to the 64-bit Intel architecture. The
resulting hw_x86_64 platform was included in the
[https://genode.org/documentation/release-notes/15.05#Principal_support_for_the_64-bit_x86_architecture
- 15.05 release].

Building on top of 'hw_x86_64' we then implemented support for running the
base-hw kernel as guest on the Muen SK. As the porting work progressed quite
quickly, this line of work was part of Genode
[https://genode.org/documentation/release-notes/15.08#Genode_on_top_of_the_Muen_Separation_Kernel
- 15.08].

Having laid the groundwork we could then tackle the task we initially set out
to do.


Architecture
~~~~~~~~~~~~

[image muen_virtualbox_architecture.pdf]

On Muen, Genode runs as a guest in VMX non-root mode without special
privileges. VirtualBox is executed as a user-level component, which makes the
architecture special in the sense that the VMM itself is running inside a
strongly isolated VM.

The guest VM managed by VirtualBox is a separate Muen subject with statically
assigned resources. Access to the guest VM memory is enabled by mapping it into
the VMMs address space at a certain offset specified in the Muen system policy.
Similarly, the guest subject state is mapped at a predefined address so
VirtualBox can manipulate e.g.  register values etc. After the initial setup,
hardware-accelerated execution of the guest VM is started by triggering a
handover event defined in the Muen system policy. The guest VM is then executed
in place of the Genode subject.

Control is handed back to VirtualBox when a trap occurs during the execution of
the guest VM, e.g. the guest accesses resources of a device that is emulated by
a VirtualBox device model. Furthermore a handover back to the VMM can be forced
by using the Muen timed event mechanism.  This prevents CPU monopolization by
the guest VM and ensures that VirtualBox gets its required share of execution
time.

Even though the VirtualBox support on Muen draws largely from the existing NOVA
implementation there are some key differences. One aspect, as mentioned above,
is that VirtualBox and its managed VM are never executed simultaneously. From
the perspective of the base-hw kernel, switching to and from the guest VM is
similar to the normal/secure world switch of
[https://genode.org/documentation/articles/trustzone - ARM TrustZone]. This
enabled us to reuse the existing base-hw VM session interface.

While on NOVA guest VM memory is donated by the VirtualBox component, the guest
has its own distinct physical memory specified in the Muen system policy. Thus
the guest VM resources including memory are all static and VirtualBox does not
need to map and unmap resources at runtime.

Since guests on Muen run in hardware-accelerated mode as much as possible,
VirtualBox does not need to emulate entire classes of instructions. One
important example is that the guest VM directly uses the hardware FPU and the
VMM does not emulate floating point instructions. Thus it does not need access
to the FPU state. This greatly reduces the implementation complexity and avoids
potential issues due to the loading of invalid FPU state.

As mentioned above, the most intriguing peculiarity is that on
'hw_x86_64_muen', VirtualBox itself is running in VMX non-root mode and thus as
a guest VM. This means that the VMM is executed like any other Muen subject
without special privileges, retaining the strong isolation properties offered
by the Muen SK. Despite this architectural difference, there is no noticeable
performance hit due to the extensive use of hardware accelerated
virtualization.


Implementation
~~~~~~~~~~~~~~

The necessary extension to the 'hw_x86_64_muen' kernel primarily consist of the
implementation of the VM session interface. A VM session is a special base-hw
kernel thread that represents the execution state of the guest VM. It is
scheduled when the guest VM is ready to continue execution.

The Vm::proceed function implements the switch to the mode transition assembly
code declared at the '_vt_vm_entry' label. The entry enables interrupts and
initiates a handover to the guest VM by invoking the event specified in the
Muen system policy.
On return from the guest VM, the VM thread is paused and the VM session client
(VirtualBox) is signaled. Once VirtualBox has performed all necessary actions,
the guest VM is resumed via invocation of the VM session 'run' function.

Another adjustment to the kernel is the use of Muen timed events for guest VM
preemption. The timer driver writes the tick count of the next kernel timer to
the guest timed events page. This causes the guest VM to be preempted at the
requested tick count and ensures that the guest VM can not monopolize the CPU
if no traps occur.

On the VirtualBox side we implemented the hwaccl layer for Muen. The main task
of this layer is keeping the guest VM machine state between VirtualBox and the
hardware accelerated execution on Muen in sync.

Depending on the guest VM exit reason, the hwaccl code decides whether to use
instruction emulation or to resume the guest VM in hardware accelerated mode.
If a trap occurred that cannot be handled by the virtualization hardware,
execution is handed to the VirtualBox recompiler that emulates the next
instruction.

Furthermore, this code also takes care of guest VM interrupts. Pending
interrupts are injected via the Muen subject pending interrupts mechanism. IRQs
are transferred from the VirtualBox trap manager state to the pending
interrupts region. If an IRQ remains pending upon returning from the guest VM,
it is copied back to the trap manager state and cleared in the subject
interrupts region.


Taking VirtualBox on Muen for a spin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Follow the [https://genode.org/documentation/platforms/muen - tutorial section]
to prepare your system for Muen.

As a next step, create a VirtualBox VM with a 32-bit guest OS of your
choice and install the guest additions
[http://download.virtualbox.org/virtualbox/4.3.36/VBoxGuestAdditions_4.3.36.iso].
In this tutorial we chose Windows 7.

Note: use guest additions close to the VirtualBox version of Genode. We have
successfully tested versions 4.3.16 and 4.3.36.

Name the virtual disk image 'win7.vdi' and create an (empty) overlay VDI as
follows:

! vboxmanage createhd --filename overlay_win7.vdi --size $size --format vdi

The VDI size (in megabytes) must match the capacity of the 'win7.vdi':

! vboxmanage showhdinfo win7.vdi

* Setup a harddisk with 4 partitions
* Format the fourth partition with an ext2 filesystem
* Copy `win7.vdi` to the root directory of the ext2 partition
* Copy `overlay_win7.vdi` to the `ram` directory of the ext2 partition

The directory structure of partition 4 should look as follows:

! /win7.vdi
! /ram/overlay_win7.vdi

Adjust the VDI UUIDs to match the ones of the Genode
[[ https://github.com/genodelabs/genode/blob/master/repos/ports/run/vm_win7.vbox#L12
| `repo/ports/run/vm_win7.vbox`]] file:

! vboxmanage internalcommands sethduuid win7.vdi 8e55fcfc-4c09-4173-9066-341968be4864
! vboxmanage internalcommands sethduuid ram/overlay_win7.vdi 4c5ed34f-f6cf-48e8-808d-2c06f0d11464

Prepare the necessary ports as follows:

! tool/ports/prepare_port dde_bsd dde_ipxe dde_rump dde_linux VirtualBox libc stdcxx libiconv x86emu qemu-usb

Create and enter the Muen build directory:

! tool/create_builddir hw_x86_64_muen
! cd build/hw_x86_64_muen
! sed -i 's/#REPOSITORIES +=/REPOSITORIES +=/g' etc/build.conf
! echo 'MAKE += -j5' >> etc/build.conf

Build the 'vbox_auto_win7' scenario:

! make run/vbox_auto_win7

This produces a Multiboot system image which can be found at
'var/run/vbox_auto_win7/image.bin'.


Limitations
~~~~~~~~~~~

The current implementation of the 'hw_x86_64_muen' VirtualBox support has the
following limitations:

* No 64-bit Windows guest support
* No Multicore guest support

Apart from these restrictions, the implementation of VirtualBox on Muen offers
the same functionality and comparable performance as VirtualBox on NOVA.


Conclusion
~~~~~~~~~~

While implementing VirtualBox support for 'hw_x86_64_muen' we encountered
several issues which required some effort to resolve. The visible effects
ranged from VirtualBox guru meditation, guest kernel panics, stalled guests and
erratic guest behavior (e.g. guest execution slow-down after some time). To
make things worse, the errors were not deterministically reproducible and
instrumenting the code could change the observable error.

One particular source of problems was the correct injection of guest
interrupts. The first approach was to define a Muen event for each guest
interrupt in the policy. When VirtualBox had a pending guest interrupt, the
corresponding event was triggered to mark it for injection upon guest VM
resumption. This approach revealed several problems.

On such issue was that interrupts could get lost due to a mismatch between
effective guest VM and VirtualBox machine state, e.g. the guest VM had
interrupts disabled and execution was handed back to the recompiler before the
pending interrupt could be injected.

Scalability was another issue, since all possible guest interrupts needed to be
specified in advance in the Muen system policy. The problem was further
compounded as guest interrupts vary depending on the operating system.

We resolved the issue by enabling monitor subjects (VirtualBox) to access the
Muen pending interrupts data structure of the associated guest VM. This simple
enhancement of Muen allows VirtualBox to directly mark guest interrupts pending
without having to trigger a Muen event or having to extend the Muen kernel.
Furthermore, keeping the pending interrupt state of the guest VM and the
VirtualBox machine state in sync is trivial and thus no interrupts are lost.

[image hw_x86_64_muen-VirtualBox-win7-bsod.jpg]

Another cause for grieve was that, by default, the VirtualBox scenarios on
Genode are configured to use multiple CPUs. This could lead to guest state
corruption since multiple emulation threads (EMT) were operating on the same
subject state. Once we had discovered the underlying cause for this problem, we
remedied the issue by clamping the guest processor count to one.

Looking back at the adventurous journey beginning with the base-hw x86_64 port
and culminating in the VirtualBox support for Muen, we are quite happy how we
were able to achieve the goal we initially set out to accomplish. We would like
to thank the always helpful guys at Genode for their support and the rewarding
collaboration!


Experimental version of VirtualBox 5 for NOVA
=============================================

We experimented with upgrading our VirtualBox 4 port to some newer VirtualBox
5 version to keep close to the current developments of VirtualBox.
Additionally, we tried with our experimental port of VirtualBox 5 to reduce
the Genode specific patches by using most of the original PGM source code
(Page Manager and Monitor). One major benefit using the original code is that
it became now feasible to enable the IEM component of Virtualbox, a
instruction emulator developed by Virtualbox, that has less overhead than
the REM (Recompiled Execution Monitor) component that is based partially on
Qemu sources.

The current state is sufficient to run Windows 7 32bit VMs on Genode/Nova
64bit. Since the port is still incomplete, largely untested for other VMs and
avoid trouble with the newly added Virtualbox4 Genode/Muen support, we
decided to make this port available as separate VMM beside the VirtualBox 4
VMM and the Seoul VMM on Genode/Nova.


Functional enhancements
=======================

commit 4f23e78f108a3521476ad4834c0028bf049d6e5a
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Wed Jun 8 20:15:27 2016 +0200

    vbox: add AHCI model
    
    Fixes #2006

commit 761db4bc73cf3a5d103f437bde0b39aed7095f9a
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Mon Jun 27 17:04:34 2016 +0200

    vbox: config option for the virtual XHCI controller
    
    This commit adds the VirtualBox configuration option
    
    <config xhci="yes">
    
    to enable the virtual XHCI controller.
    
    Fixes #2028

commit 22e908e8014cda9a02af72ae11278d2bd7ae94a6
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Mon Jun 27 14:38:43 2016 +0200

    vbox: add config option to enforce use of IOAPIC
    
    The virtual PCI model delivers IRQs to the PIC by default and to the
    IOAPIC only if the guest operating system selected the IOAPIC with the
    '_PIC' ACPI method and if it called the '_PRT' ACPI method afterwards.
    When running a guest operating system which uses the IOAPIC, but does
    not call these ACPI methods (for example Genode/NOVA), the new
    configuration option
    
    <config force_ioapic="yes">
    
    enforces the delivery of PCI IRQs to the IOAPIC.
    
    Fixes #2029


Base framework
##############

Cultivation of the new text-output API
======================================

; @nfeske

; * Added print methods for commonly used
;   types like 'Capability', 'Framebuffer::Mode', 'Mac_address'),
;   removal of old debug macros from the code base

commit 2030ae678ef9166c7d12ff7222005caca4e35092
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Thu Jun 16 15:55:36 2016 +0200

    Supplement base/log.h with raw output function
    
    This patch introduces the Genode::raw function that prints output
    directly via a low-level kernel mechanism, if available.
    
    On base-linux, it replaces the former 'raw_write_str' function.
    On base-hw, it replaces the former kernel/log.h interface.
    
    Fixes #2012

commit c8fe0df0ed5dd59f4780e84e801f811ca56166b8
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Fri Jun 24 11:46:29 2016 +0200

    Overloads for printing signed/unsigned/bool base types
    
    Issue #1942

commit 38a1e959790af636d51434ae3486da40c055cde3
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Jul 13 15:15:03 2016 +0200

    base: add 'String::print' method
    
    This way, we can conveniently output strings without calling the
    string() method.

commit 7e73645d9e84f16d1fdf46b9c01a087de8844470
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Mon Aug 15 12:20:52 2016 +0200

    base: helper for printing individual characters

commit 0bf2e4a794f781803b9164c352619a0988818cd3
Author: Johannes Schlatow <schlatow@ida.ing.tu-bs.de>
Date:   Tue Aug 9 16:54:13 2016 +0200

    base: print() functions for floating point types
    
    Fixes #2055


commit 3c73ba62c4950e3116029132a2fd0265b498446e
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Jul 13 19:07:09 2016 +0200

    base: avoid use of deprecated base/printf.h
    
    Besides adapting the components to the use of base/log.h, the patch
    cleans up a few base headers, i.e., it removes unused includes from
    root/component.h, specifically base/heap.h and
    ram_session/ram_session.h. Hence, components that relied on the implicit
    inclusion of those headers have to manually include those headers now.
    
    While adjusting the log messages, I repeatedly stumbled over the problem
    that printing char * arguments is ambiguous. It is unclear whether to
    print the argument as pointer or null-terminated string. To overcome
    this problem, the patch introduces a new type 'Cstring' that allows the
    caller to express that the argument should be handled as null-terminated
    string. As a nice side effect, with this type in place, the optional len
    argument of the 'String' class could be removed. Instead of supplying a
    pair of (char const *, size_t), the constructor accepts a 'Cstring'.
    This, in turn, clears the way let the 'String' constructor use the new
    output mechanism to assemble a string from multiple arguments (and
    thereby getting rid of snprintf within Genode in the near future).
    
    To enforce the explicit resolution of the char * ambiguity, the 'char *'
    overload of the 'print' function is marked as deleted.
    
    Issue #1987


Revised utilities for the handling of session labels
====================================================

; @nfeske  !!! note the API incomptibility !!!

commit f8337b511b83da81cd1e4fa7b6377f4c06856dbd
Author: Emery Hemingway <emery@vfemail.net>
Date:   Tue Jan 12 14:11:58 2016 +0100

    Move Session_label from os to base
    
    Session_label constructor now takes a bare string rather than a
    serialized argument buffer.
    Replace all instances of previous constructor with 'label_from_args'
    function.
    
    Issue #1787


Low-level OS infrastructure
###########################

Network-transparent ROM sessions to a remote Genode system
==========================================================

[image remote_rom]

; @valivalpas

commit 2687de237690e53ea4c756afea45a4779fc550c7
Author: Johannes Schlatow <schlatow@ida.ing.tu-bs.de>
Date:   Tue Jul 5 11:51:45 2016 +0200

    Add remote_rom proxy component
    
    Fixes #20


Statistical profiling
=====================

[image cpu_sampler]

; @cproc


Init configuration changes
==========================

; @nfeske

commit 877676c29f6071eb97103c1112df681e937d679d
Author: Emery Hemingway <emery@vfemail.net>
Date:   Wed Mar 9 15:06:42 2016 +0100

    Make label-based policy selection more strict
    
    A configuration policy must match against a policy node label,
    label_prefix, or label_suffix atttribute. A fallback to
    <default-policy/> is provided as a label wildcard.
    
    Fixes #1901


Configurable mapping of ACPI events to input events
===================================================

With the last release we added support for detection of dynamic ACPI stat changes
like some Fn * keys, Lid close/open and battery status information.
Unfortunately, not all state changes are reported the same way on various
notebooks, e.g. Fn * keys may get reported as ordinary PS/2 input events, or
are reported via the Embedded controller. Lid close/open changes may be reported
by a ACPI Lid event or by the embedded controller.

To be able to handle those different event sources uniformly in Genode
applications, we added a component which transforms ACPI events to Genode
input session events. The component is located in
repos/libports/server/acpi_input and can be configured as shown below:

! <start name="acpi_input">
!  <resource name="RAM" quantum="1M"/>
!   <provides><service name="Input"/></provides>
!   <config>
!   <!-- example mapping - adapt to your target notebook !!! -->
!   <!-- as="PRESS_RELEASE" is default if nothing specified -->
!   <map acpi="ec"      value="25"      to_key="KEY_VENDOR"/>
!   <map acpi="ec"      value="20"      to_key="KEY_BRIGHTNESSUP"/>
!   <map acpi="ec"      value="21"      to_key="KEY_BRIGHTNESSDOWN"/>
!   <map acpi="fixed"   value="0"       to_key="KEY_POWER"  as="PRESS_RELEASE"/>
!   <map acpi="lid"     value="CLOSED"  to_key="KEY_SLEEP"  as="PRESS"/>
!   <map acpi="lid"     value="OPEN"    to_key="KEY_SLEEP"  as="RELEASE"/>
!   <map acpi="ac"      value="ONLINE"  to_key="KEY_WAKEUP"/>
!   <map acpi="ac"      value="OFFLINE" to_key="KEY_SLEEP"/>
!   <map acpi="battery" value="0"       to_key="KEY_BATTERY"/>
! ...

The ACPI event source can be the embedded controller (ec), a fixed ACPI event
(fixed), the notebook lid (lid), a ACPI battery (battery) or the ACPI
alternating current (ac) status. The value of the event source can be
mapped to a Genode input session key as either a a single press or release
input event or as both.


Utility servers for base services
=================================

Four new servers were added to the world repository. These so-called "shim servers" do
not provide services by themselves but are intended to be imposed between clients and
full-fledged servers to provide some extra functionality. They are summarized here and
each is accompanied with README in the world repository.

The rom_fallback server was created for scenarios where a system is expected
to be populated with new components in a dynamic and intuitive way. ROM requests
that arrive at rom_fallback are forward through a list of possible routes and the first
successfully opened session is returned. Example use would be to fetch objects remotely
that are not present initially using the tftp_rom server, or in the future to override
objects provided by a package manager with local versions.

When using the framework as a primary operating system there is a need to view log
information both in real-time and retrospectively without the aid of an external host.
The new log_tee server can be used to duplicate and reroute log streams at arbitrary
points in the component tree. This allows information to be simultaneously directed
on-screen and to local storage as an example.

The remaining two were creating with emulated gaming in mind, input_remap and fb_upscale.
Hardware emulators for gaming are typically provide local facilities for customizing
input and scaling and shading graphics. A componentized architecture allows these tasks
to performed externally for greater flexibility. The input_remap server modifies input
events to remap keys and buttons. This allows emulation to target only an idealized set
of controller inputs without compromising the users ability to remap. It is equally suited
to adjusting keyboard layouts. The fb_upscale server enlarges a small client framebuffer
to a larger, modern display. This encourages emulation to focus on pixel-accurate output
rather than account for personal preference in the final render.


Libraries and applications
##########################

Ported 3rd-party software
=========================

; @nfeske

commit 868bf6c9d0bd367e1fce8df2117f3bf717c3e2e8
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Wed Jun 8 14:35:11 2016 +0200

    noux-pkg: port of diffutils 3.3
    
    Fixes #2005

commit b80939cc0a0ed80ba236c8fa831601908525cfc6
Author: Josef SÃ¶ntgen <josef.soentgen@genode-labs.com>
Date:   Thu Oct 4 11:33:57 2012 +0200

    Noux: add noux-pkg/less
    
    Issue #2014


commit 45570065fda39d15a00675371d3be10e9a3ef2c3
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Sat Aug 20 21:17:17 2016 +0200

    Port of libxml2

commit 10a42e8c145d3d63df27bcee421f15c25ef912af
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Mon Apr 25 12:58:03 2016 +0200

    Port of mbed TLS
    
    Thanks to Menno Valkema for the initial patch.
    
    Fixes #17


File-downloading component based on libcurl
===========================================

A native front end to the curl library was crafted, _fetchurl_.
This utility is intended as a source or package management
primitive.

:Fetchurl at the Genode-World repository:

  [https://github.com/genodelabs/genode-world/tree/master/src/app/fetchurl]

As a warning, fetchurl sidesteps the verification of transport
layer security and is expected to be used where content can be
verified out-of-band.


RISC-V front-end server
=======================

In version
[http://genode.org/documentation/release-notes/16.02#New_support_for_the_RISC-V_CPU_architecture - 16.02],
Genode gained support for the RISC-V CPU architecture. Genode can be
executed on either a simulator or a synthesized FPGA softcore, e.g., on Xilinx
Zynq FPGAs. On the latter platform, the RISC-V core is a secondary CPU that
accompanies an ARM core built-in in the FPGA. The ARM core usually run a Linux
system. The Linux system interacts with the RISC-V system via a so-called
front-end server, which allows the management of the RISC-V core and the
retrieval of log output.

Thanks to the added Zynq support described in Section
[Execution on bare Zynq hardware (base-hw)], is is possible to run Genode
on the ARM core of Zynq FPGAs as well. So a single Zynq FPGA can effectively
host two Genode systems at the same time, one running on a RISC-V softcore CPU
and one running on ARM. A ported version of the RISC-V front-end server
enables the ARM-based Genode system to interact with the RISC-V-based Genode
system. This scenario is described in detail in the README file of the port:

:RISC-V front-end server at the Genode-world repository:

  [https://github.com/genodelabs/genode-world/tree/master/src/app/fesrv]

Thanks to Menno Valkema of [https://nlcsl.com/ - NLCSL] for contributing
this line of work!


Platforms
#########

Binary compatibility across all supported kernels
=================================================

Since its inception, Genode provides a uniform API that abstracts from the
underlying kernel. This way a component developed once for one kernel can be
easily re-targeted to other kernels by mere re-compilation. With version
16.08, we go even a step further: Dynamically linked executables and libraries
have become kernel-agnostic. That means that a single binary is able to run on
various kernels with no recompilation needed.

To make this possible, two steps were needed:

* The Genode ABI - the binary interface provided by Genode's dynamic
  linker - had to become void of any kernel specifics. The kernel-specific
  code had to become completely encapsulated within the dynamic linker
  and Genode's core component.

* The Genode API - the header files as included by components during
  their compilation - must not reveal any types or interfaces of a
  specific kernel. The representation of all Genode types had to be
  generalized.

This effort required us to form a holistic view of the kernel interfaces
of all 8 kernels supported by Genode, which made the topic very
challenging and exciting. The biggest stumbling blocks were the parts
of the API that were traditionally mapped directly to kernel-specific data
types, in particular the representation of capabilities.
The generalized capability type is based on the version originally developed
for base-sel4. All traditional L4 kernels and Linux use the same
implementation of the capability-lifetime management. On base-hw, NOVA,
Fiasco.OC, and seL4, custom implementations (based on their original
mechanisms) are used, with the potential to unify them further in the
future.

At the current stage, all dynamically linked programs (such as any program
that use the C library) are no longer tied of a specific kernel but can
be directly executed on any kernel supported by Genode. E.g., a Qt5
application - once built for Genode - can be run directly on Linux and seL4
with no recompilation needed. This paves the ground for the efficient
implementation of binary packages in the near future.

It is still possible to create kernel-specific components that leverage
certain kernel features that are not accessible through Genode's API. For
example, our version of VirtualBox facilitates the direct use of the kernel.
Or Genode's set of pseudo device drivers for Linux interact directly with the
Linux kernel. But those components are rare exceptions.


Execution on bare Zynq hardware (base-hw)
=========================================

; @valivalpas

commit ecfb4e490408b2735b34191cd0a15a959326ebc6
Author: Timo Wischer <t.wischer@tu-bs.de>
Date:   Thu Mar 24 17:27:12 2016 +0100

    zynq: add sd_card driver

commit 6418f3408283ee17bf8aefcd7346e78b8cc18940
Author: Mark <albers@ida.ing.tu-bs.de>
Date:   Thu Mar 24 17:03:20 2016 +0100

    zynq: add gpio, i2c and vdma drivers

commit 2e7bb650dce72842cd46b90638467baddaee2d3f
Author: Johannes Schlatow <schlatow@ida.ing.tu-bs.de>
Date:   Thu Mar 24 14:52:10 2016 +0100

    zynq: add specs for zynq-based boards
    
    - zynq_parallella
    - zynq_zedboard
    - zynq_zc706
    - zynq_zc702


Removal of stale features
#########################

We removed the *tar_fs* server because it is superseded by the VFS server
with its built-in support for mounting TAR archives.


