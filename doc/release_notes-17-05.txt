

              ===============================================
              Release notes for the Genode OS Framework 17.05
              ===============================================

                               Genode Labs



; intro
; @nfeske


Package management
##################

; @nfeske

commit 44e5f1c2d43941ea19838ecb791b38adaa12a5ee
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Thu Mar 30 18:01:39 2017 +0200

    ABIs for libm, libpng, zlib

commit 3a14fb5877f1ebcffa4c3c53c883019d15e153aa
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Tue Mar 28 18:41:41 2017 +0200

    Tool for assembling API/source/binary archives
    
    Issue #2339

commit 2c05b7fec2c16ebc7bfee77a61f06f206662080e
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Tue Mar 28 18:42:41 2017 +0200

    Depot-archive recipes
    
    Issue #2339

commit 5a45d41e89d7353a3577554426ce953e336af345
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Mar 29 16:04:07 2017 +0200

    run: support for accessing depot content
    
    Run scripts can use the new 'import_from_depot' function to incorporate
    archive content from the depot into a scenario. The function must be
    called after the 'create_boot_directory' function and takes any number
    of pkg, src, or raw archives as arguments. An archive is specified as
    depot-relative path of the form <user>/<type>/name. Run scripts may
    call 'import_from_depot' repeatedly.
    
    An argument can refer to a specific version of an archive or just the
    version-less archive name. In the latter case, the current version (as
    defined by a corresponding archive recipe in the source tree) is used.
    
    If a 'src' archive is specified, the run tool integrates the content of
    the corrsponding binary archive into the scenario. The binary archives
    are selected according the spec values as defined for the build directory.
    As of now, only x86_32 and x86_64 are supported by the 'depot_spec'
    function.
    
    Issue #2339

commit cc85939f57f6fd72c8f45c329739c06cdbf31859
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Fri Apr 14 19:19:39 2017 +0200

    gems: import run-script ingredients from depot
    
    This patch adjusts the interactive scenarios of the gems repository to
    use the depot. This has three immediate benefits. First, once the depot
    is populated with binary archives, the start time of the scenarios
    becomes very quick because most dependency checks and build steps are
    side-stepped. Second, the run scripts become more versatile. In
    particular, run scripts that were formerly supported on base-linux only
    (nit_fader, decorator, menu_view) have become usable on all base
    platforms that have a 'drivers_interactive' package defined. Finally,
    the run scripts have become much shorter.
    
    Issue #2339

commit e312f79ce9a9dce0de811568c4e557d1eb05996a
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Sun May 14 21:58:56 2017 +0200

    Recipes for noux API, bash, posix


Base framework
##############

New revision of the Genode Foundations book
===========================================

Genode underwent substantial changes over the coures of the past year. This
prompts us to update the "Genode Foundations" book to reflect the most current
state of the framework. Specifically, the changes since the last year's
edition are:

: <div class="visualClear"><!-- --></div>
: <p>
:  <div style="clear: both; float: left; margin-right:20px;">
:   <a class="internal-link" href="https://genode.org">
:    <img class="image-inline" src="http://genode.org/documentation/genode-foundations-title.png">
:   </a>
:  </div>
: </p>

* The consolidation of the PD and RAM services of core,
* The assignment and trading of capability quotas,
* An extension of the getting-starting section with an example of a typical
  component skeleton and the handling of external events,
* New init-configuration features, including the use of unscoped labels,
  state report, service forwarding, and label rewriting,
* The use of kernel-agnostic build directories,
* A new under-the-hood description of the asynchronous parent-child interplay,
* An updated API reference

: <div class="visualClear"><!-- --></div>

To see the changes in detail, please refer to the book's
[https://github.com/nfeske/genode-manual/commits/master - revision history].


Completed component transition to modern API
============================================

One year ago, we profoundly
[https:/documentation/release-notes/16.05#The_great_API_renovation - overhauled Genode's API].
The modernized framework interface promotes a safe programming style that greatly
reduces the chances for memory-safety bugs, eases the assessment of the code
by shunning the use of global side effects, and models the internal state of
components in an explict way. We are happy to report that we have updated
almost all of Genode's over 400 components to the new API now, so that we can
fade out the deprecated legacies from our past.

Originally, we planned to drop the deprecated API altogether with the current
release. But we will hold on for one release cycle as we identified a few
components that we better replace by new implementations rather than updating
them, i.e., our old Mesa EGL back end that will be replaced in August, or a
few libc plugins that are superseded by the recently introduced VFS
infrastructure. By keeping the compatibility with the old API for a bit
longer, we are not forced to drop those components before their replacements
are in place.


Streamlining exception types
============================

During the organic evolution of the Genode API, we usually introduced
exception types as needed without a global convention. In particular
the exception types as thrown by RPC functions were usually defined
in the scope of the RPC interface. This approach ultimately led to a
proliferation of ambiguously named exception types such as
'Root::Quota_exceeded' and 'Ram_session::Quota_exceeded'.

With the current release, we replace the organically grown exception landscape
by a framework-wide convention. The following changes ease the error handling
(there are fewer exceptions to handle), alleviates the need to convert
exceptions along the session-creation call chain, and avoids possible aliasing
problems (catching the wrong type with the same name but living in a different
scope):

* RPC functions that demand a session-resource upgrade no longer reflect this
  condition via a session-specific exception but via the new 'Out_of_ram'
  or 'Out_of_caps' exception types, declared in _base/quota_quard.h_.

* The former 'Parent::Service_denied', 'Parent::Unavailable',
  'Root::Invalid_args', 'Root::Unavailable', 'Service::Invalid_args',
  'Service::Unavailable', and 'Local_service::Factory::Denied' types have
  been replaced by the single 'Service_denied' exception type defined in
  'session/session.h'.
  This simplification eliminates ambiguities and removes the need to convert
  exception types along the path of the session creation.

* The former 'Parent::Quota_exceeded', 'Service::Quota_exceeded', and
  'Root::Quota_exceeded' exceptions are covered by the single
  'Insufficient_ram_quota' exception type now.

* The 'Parent' interface has become able to distinguish between 'Out_of_ram'
  (the child's RAM is exhausted) and 'Insufficient_ram_quota' (the child's
  RAM donation does not suffice to establish the session).

* The 'Allocator::Out_of_memory' exception has become an alias for 'Out_of_ram'.


Assignment and trading of capability quotas
===========================================

Genode employs a resource-trading scheme for memory management. Under this
regime, parent components explicitly assign memory to child components, and
client components are able to "lend" memory to servers. (the details are
described in the "Genode Foundations" book).

Even though capabilities are data structures (residing in the kernel), their
costs cannot be accounted via Genode's regular memory-trading scheme because
those data structures are - generally speaking - not easily extensible by the
user land on top of the kernel. E.g., on Linux where we use file descriptors
to represent capabilities, we are bound by the fd-limit of the kernel. On
base-hw, the maximum number of capabilities is fixed at the build time of the
kernel and used to dimension statically allocated data structures. Even on
seL4 (which in principle allows user memory to be turned into kernel memory),
the maximum number of capabilities is somehow limited by the ID namespace
within core. For this reason, capabilities should be regarded as a limited
physical resource from the component's point of view, very similar to how
physical memory is modeled at a limited physical resource.

On Genode, any regular component implicitly triggers the allocation of
capabilities whenever a RPC object or a signal context is created. As previous
versions of Genode did not impose a limit on how many capabilities a component
can allocate, a misbehaving component may exhaust the system-global capability
space and thereby poses a denial-of-service threat. The current version solves
this problem by mirroring the accounting and trading scheme that Genode
employs for physical memory to the accounting of capability allocations.

Capability quotas must now be explicitly assigned to subsystems by specifying
a 'caps=<amount>' attribute to init's start nodes. Analogously to RAM quotas,
cap quotas can be traded between clients and servers as part of the session
protocol. The capability budget of each component is maintained by the
component's corresponding PD session at core.

At the current stage, the accounting is applied to RPC capabilities,
signal-context capabilities, dataspace capabilities, and static per-session
capability costs. Capabilities that are dynamically allocated via core's CPU
and TRACE service are not yet covered. Also, the capabilities allocated by
resource multiplexers outside of core (like nitpicker) must be accounted by
the respective servers, which is not covered yet. The static per-session
capability costs are declared via the new 'CAP_QUOTA' enum value in the scope
of the respective session type. The value is used by clients to dimension a
session's initial quota donation, and by servers to validate the session
construction argument against the 'CAP_QUOTA' value as written in the
"contract" (the session interface).

If a component runs out of capabilities, core's PD service prints a warning to
the log. To observe the consumption of capabilities per component in detail,
the PD service is equipped with a diagnostic mode, which can be enabled via
the 'diag' attribute in the target node of init's routing rules. E.g., the
following route enables the diagnostic mode for the PD session of the "timer"
component:

! <default-route>
!   <service name="PD" unscoped_label="timer">
!     <parent diag="yes"/>
!   </service>
!   ...
! </default-route>

For subsystems based on a sub-init instance, init can be configured to report
the capability-quota information of its subsystems by adding the attribute
'child_caps="yes"' to init's '<report>' configuration node. Init's own
capability quota can be reported by adding the attribute 'init_caps="yes"'.


Merged RAM and PD services of the core component
================================================

Traditionally, Genode's core component used to decouple the management of RAM
from the notion of protection domains (PD). Both concerns were addressed by
separate core services. While nice from an academic point of view, in
practice, this separation did not provide any tangible benefit. As a matter of
fact, there is a one-to-one relationship between PD sessions and RAM sessions
in all current Genode systems. As this superficial flexibility is needless
complexity, we identified the potential to simplify core as well as the
framework libraries by merging the RAM session functionality into the PD
session interface.

Since the implementation of capability-quota accounting as explained in
Section [Assignment and trading of capability quotas], PD sessions already
serve the role of an account for physical resources, which was previously a
distinctive feature of RAM sessions. That includes the support for trading
resource quotas between sessions, and the definition of a reference account.
The only unique functionality provided by the RAM service is the actual
allocation and deallocation of RAM. So the consolidation appeared as a natural
step to take.

From the framework's API perspective, this change mainly affects the use case
of the 'Ram_session' interface as a physical-memory allocation back end. This
use case is covered by the new 'Ram_allocator' interface, which is implemented
by the 'Pd_session' and contains the subset of the former RAM session
interface that is needed to satisfy the needs of the 'Heap' and 'Sliced_heap'.
Its narrow scope makes it ideal for intercepting memory allocations as done by
the new 'Constrained_ram_allocator' wrapper class, which is meant to replace
the existing _base/allocator_guard.h_ and _os/ram_session_guard.h_.

From a system integrator's point of view, the change makes the routing of
environment sessions to core's RAM service superfluous. Routes to core's RAM
service along with the corresponding '<parent-provides>' declarations can
safely be removed from run scripts.


Explicit execution of static constructors
=========================================
; @chelmuth

commit cb43e04691d3cdb5f2052a2fd7d5999c70047b54
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Wed Mar 15 15:40:55 2017 +0100

    ldso: defer execution of static constructors
    
    Ldso now does not automatically execute static constructors of the
    binary and shared libraries the binary depends on. If static
    construction is required (e.g., if a shared library with constructor is
    used or a compilation unit contains global statics) the component needs
    to execute the constructors explicitly in Component::construct() via
    Genode::Env::exec_static_constructors().
    
    In the case of libc components this is done by the libc startup code
    (i.e., the Component::construct() implementation in the libc).
    
    The loading of shared objects at runtime is not affected by this change
    and constructors of those objects are executed immediately.
    
    Fixes #2332


Separation of I/O signals from application-level signals
========================================================
; @chelmuth

commit 9f83fa9a79e37f51e7f7bc89b72224d7da5932b4
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Mon Apr 3 10:45:51 2017 +0200

    base: classify signals as I/O and application level
    
    Fixes #2363

OS-level libraries and components
#################################

Dynamic resource management and service forwarding via init
===========================================================

The
[https:/documentation/release-notes/17.02#Dynamically_reconfigurable_init_component - previous release]
equipped Genode's init component with the ability to be used as dynamic
component-composition engine. The current release extends this approach
to the dynamic balancing of memory assignments, and introduces the forwarding
of session requests from init's parent to init's children.


Responding to binary-name changes
---------------------------------

By subjecting the ROM module request for the ELF binary to init's regular
routing and label-rewriting mechanism instead of handing it as a special case,
init's '<binary>' node has become merely syntactic sugar for a route like the
following:

!<start name="test"/>
!  <route>
!    <service name="ROM" unscoped_label="test">
!      <parent label="test-binary-name"/> </service>
!      ...
!  </route>
!  ...
!</start>

A change of the binary name has an effect on the child's ROM route to the
binary and thereby implicitly triggers a child restart due to the existing
re-validation of the routing.


Optional version attribute for start nodes
------------------------------------------

The now 'version' attribute allows for the forced restart of a child with an
otherwise unmodified start node. The specified value is also reflected in
init's state report such that a subsystem management component is able to
validate the effects of an init configuration change.


Applying changes of '<provides>' nodes
--------------------------------------

The new version of init is able to apply changes of any server's '<provides>'
declarations in a differential way. Servers can in principle be extended by
new services without re-starting them. Of course, changes of the '<provides>'
declarations may affect clients or would-be clients as this information is
taken into account for the session routing.


Responding to RAM-quota changes
-------------------------------

If the RAM quota is decreased, init withdraws as much quota from the child's
RAM session as possible. If the child's RAM session does not have enough
available quota, a resource-yield request is issued to the child. Cooperative
children may respond to such a request by releasing memory.

If the RAM quota is increased, the child's RAM session is upgraded. If the
configuration exceeds init's available RAM, init re-attempts the upgrade
whenever new slack memory becomes available (e.g., by disappearing other
children).

The formerly built-in policy of responding to resource requests with handing
out slack quota does not exist anymore. Instead, resource requests have to be
answered by an update of the init configuration with adjusted quota values.

Note that this change may break run scripts that depend on init's original
policy. Those run scripts may be adjusted by increasing the quota for the
components that use to inflate their RAM usage during runtime such that the
specified quota suffices for the entire lifetime of the component.


Service forwarding
------------------

Init has become able to act as a server that forwards session requests to its
children. Session requests can be routed depending of the requested service
type and the session label originating from init's parent.

The feature is configured by one or multiple '<service>' nodes hosted in
init's '<config>' node. The routing policy is selected by via the regular
server-side policy-selection mechanism, for example:

! <config>
!   ...
!   <service name="LOG">
!     <policy label="noux">
!       <child name="terminal_log" label="important"/>
!     </policy>
!     <default-policy> <child name="nitlog"/> </default-policy>
!   </service>
!   ...
! </config>

Each policy node must have a '<child>' sub node, which denotes the name of the
server via the 'name' attribute. The optional 'label' attribute defines the
session label presented to the server, analogous to how the rewriting of
session labels works in session routes. If not specified, the client-provided
label is presented to the server as is.


New framework for userlevel timing
==================================

In the past, application level timing was almost directly build on the bare
Timer session interface. Thus, developers themselves had to deal with the
deficiencies of the cross-component protocol:

* a Timer session can not manage multiple timeouts at once,

* binding timeout signals to handler methods must be done manually,

* the precision is limited to milliseonds, and

* the session interface leaves a lot of space and also the need for individual
  front-end implementations which makes maintenance of timing aspects harder
  in general.

The new timeout framework is a wrapper for the Timer session. It raises the
abstraction level and narrows the interface according to our experiences with
former solutions. It is mainly motivated by the broadly used 'Signal_handler'
class and in that is a clear step away from blocking timeouts (e.g. usleep,
msleep). Furthermore, it provides scheduling of multiple timeouts at one Timer
session, local time-interpolation for higher precision, and integrated
dispatching to individual handler methods.

The credentials of the framework are the three classes 'Timer::Connection',
'Timer::Periodic_timeout', and 'Timer::One_shot_timeout' that can be found all
together in the 'timer_session/connection.h' header. Let's visualize their
application with some small examples. Assume you have two object members that
you'd like to sample every 1.5 seconds respectively everey 2 seconds. You can
achieve this as follows:

! #include <timer_session/connection.h>
!
! using namespace Genode;
!
! struct Data
! {
! 	unsigned value_1, value_2;
!
! 	void handle_timeout_1(Duration elapsed) { log("Value 1: ", value_1); }
! 	void handle_timeout_2(Duration elapsed) { log("Value 2: ", value_2); }
!
! 	Timer::Periodic_timeout<Data> timeout_1, timeout_2;
!
! 	Data(Timer::Connection &timer)
! 	: timeout_1(timer, *this, &Data::handle_timeout_1, Microseconds(1500000)),
! 	  timeout_2(timer, *this, &Data::handle_timeout_2, Microseconds(2000000)) { }
! };

The periodic timeouts take a Timer connection as construction parameter. You
can use the same Timer connection for multiple timeouts. Additionally, you
have to tell the timeout constructor which handler method to call and on which
object. A handler method has no return value and one parameter 'elapsed',
which contains the time since the creation of the underlying Timer connection.
As its last parameter, the timeout constructor takes the period length.
Periodic timeouts start automatically calling the handler methods on the
object with the given period.

If you now would like to sample the members only once, adapt the example as
follows:

! struct Data
! {
! 	...
!
! 	Timer::One_shot_timeout<Data> timeout_1, timeout_2;
!
! 	Data(Timer::Connection &timer)
! 	: timeout_1(timer, *this, &Data::handle_timeout_1),
! 	  timeout_2(timer, *this, &Data::handle_timeout_2)
! 	{
! 		timeout_1.schedule(Microseconds(1500000));
! 		timeout_2.schedule(Microseconds(2000000));
! 	}
! };

In constrast to a periodic timeout, a one-shot timeout is started
manually with the 'schedule' method. It can be started multiple times
with different timeout lengths. You can also restart the timeout inside the
handler method itself:

! struct Data
! {
! 	Timer::One_shot_timeout<Data> timeout;
!
! 	void handle(Duration elapsed) { timeout.schedule(Microseconds(1000)); }
!
! 	Data(Timer::Connection &timer) : timeout(timer, *this, &Data::handle)
! 	{
! 		timeout.schedule(Microseconds(2000));
! 	}
! };

Furthermore, you can discard a one-shot timeout and check wether it is active
or not:

! struct Data
! {
! 	Timer::One_shot_timeout<Data> timeout;
!
! 	...
!
! 	void abort_sampling()
! 	{
! 		if (timeout.scheduled()) {
! 			timeout.discard();
! 		}
! 	}
! };

The lifetime of a Timer connection can be read out also independent from any
timeout via the 'Timer::Connection::curr_time' method. In general, the Timer
session lifetime provided through 'curr_time' or the timeout-handler parameter
is calculated using the remote time as well as a local interpolation. This
raises the precision up to the level of microseconds. The interpolation
happens transparently. The only thing to remember is that a Timer connection
always needs some time (approximately 1 second) after construction to reach
this precision because the interpolation parameters are determined
empirically.

Although having this improved new timeout interface, the Timer connection
stays backwards-compatible for now. However, the modern and the legacy
interface cannot be used in parallel at one connection. Thus, a Timer
connection now has two modes. Initially it is in the legacy mode with the raw
session interface and blocking calls like 'usleep' and 'msleep' available.
But as soon as the new timeout interface is used for the first time, it
permanently switches to the modern mode. Attempts to use the legacy interface
in the modern mode cause an exception.

The timeout framework is part of the base library which means that it is
automatically available in each Genode component.

For technical reasons, the lifetime precision up to microseconds cannot be
provided when using Fiasco.OC or Linux on ARM platforms.

For a comprehensive example of how to use the timeout framework, see the run
script 'os/run/timeout.run' respectively the corresponding test component
'os/src/test/timeout'.


In-band notifications in file-system session
============================================
; @emery

With capability accounting in place we are compelled to examine the framework
for any wasteful allocation of capablities. Prior to this release it was convenient to
allocate signal contexts for any number of application contexts. It is now apparent
that signals should instead drive a fixed number of state machine transitions that
monitor application state by other means. A good example of this is the File_system
session.

Previously a component would watch for changes to a file by associating a signal
context at the client with an open file context at the server. As signals carry no
payload or metadata the client would be encouraged to allocate a new signal context for
each file it monitored. In practice this rarely caused problems but nevertheless there
lurked a limit to scalability.

This release eliminates the allocation of additional signal contexts over the lifetime
of a 'File_system' session by incorporating notifications into the existing asynchronous
I/O channel. I/O at the 'File_system' session operates via a circular packet buffer. Each
packet contains metadata associating an operation with an open file handle. In this release
we define the new packet type 'CONTENT_CHANGED' to request and to receive notifications of
changes to an open file. This limits the signal capabilities allocated to those of the packet
handlers and consolidates I/O and notification handling to no less than a single per-session
signal handler at client and server.


Log-based CPU-load display
==========================

The new component 'top' obtains information about the existing trace subjects
from core's "TRACE" service, as the cpu_load_monitor does, and shows via the
LOG session the highest CPU consumers per CPU in percentage. The tool is
especially handy if no graphical setup is available, in contrast to the
cpu_load_monitor app. Additionally, the actual thread and process name can be
obtained from logs. By the attribute 'period_ms' the timeframe for requesting,
processing and showing the cpu load can be configured:

!<config>
! <parent-provides>
!  <service name="TRACE"/>
! </parent-provides>
! ...
! <start name="top">
!  <resource name="RAM" quantum="2M"/>
!  <config period_ms="2000"/>
! </start>
!</config>

A example output looks like:

! [init -> top] cpu=0.0  98.16% thread='idle0' label='kernel'
! [init -> top] cpu=0.0   0.74% thread='test-thread' label='init -> test-trace'
! [init -> top] cpu=0.0   0.55% thread='initial' label='init -> test-trace'
! [init -> top] cpu=0.0   0.23% thread='threaded_time_source' label='init -> timer'
! [init -> top] cpu=0.0   0.23% thread='initial' label='init -> top'
! [init -> top] cpu=0.0   0.04% thread='signal handler' label='init -> test-trace'
! [init -> top] cpu=1.0 100.00% thread='idle1' label='kernel'

Network-traffic monitoring
==========================

The new 'nic_dump' server in 'os/src/server/nic_dump' is a bump-in-the-wire
component for the NIC service. It does deep packet inspection for each passing
packet and dumps the gathered information to its LOG session. This includes
information about Ethernet, ARP, IPv4, TCP, UDP, and DHCP by now. The
monitored information can also be stored to a file by using the 'fs_log'
server or printed to a terminal session using the 'terminal_log' server.

Here is an examplary  snippet of Init-configuration that integrates the NIC
dump into a scenario between a NIC bridge and a NIC router.

! <start name="nic_dump">
! 	<resource name="RAM" quantum="6M"/>
! 	<provides> <service name="Nic"/> </provides>
! 	<config uplink="bridge" downlink="router" time="yes"/>
! 	<route>
! 		<service name="Nic"> <child name="nic_bridge"/> </service>
! 		...
! 	</route>
! </start>

As you can see, NIC dump knows three config parameters by now. The parameters
'uplink' and 'downlink' determine how the two NIC session are called in the
output. The 'time' parameter decides wether to print a timestamp in front of
each packet dump or not. What protocol information is printed and in which
format is not configurable yet. But it can be altered in the 'print'
methods of the corresponding protocol classes. You can find them in the 'net'
library in 'os/src/lib/net' respectively 'os/include/net'.

For a comprehensive example of how to use the NIC dump, see the
run script 'libports/run/nic_dump.run'.


POSIX libc profile as shared library
====================================

As described in the
[https:/documentation/release-notes/17.02#New_execution_model_of_the_C_runtime - previous release notes],
the 'posix' library supplements Genode's libc with an implementation of a
'Libc::Component::construct' function that calls a traditional 'main'
function. It is primarily being used for ported 3rd-party software. As the
library is just a small supplement to the libc, we used to provide it as a
static library. However, by providing it as shared object with an ABI, we
effectively decouple the posix-library-using programs from the library
implementation, which happens to depend on several OS-level APIs such as the
VFS. We thereby eliminate the dependency of pure POSIX applications from the
Genode-API details.

This change requires all run scripts that depend on POSIX components to
extend the list of boot modules as passed to 'build_boot_image' with
'posix.lib.so'.


State reporting of block-device-level components
================================================
; @chelmuth

commit caafb4b17fa035bd91f62ec142557ce36d1cf713
Author: Boris Mulder <boris.mulder@nlcsl.com>
Date:   Thu May 18 11:12:11 2017 +0200

    part_blk: added optional partitions report

commit c0e7ec2416d9ca40972c547f047e220c23243fcc
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Sun May 14 17:02:59 2017 +0200

    ahci: optionally report discovered devices
    
    Issue #2417


Runtimes and applications
#########################

Feature-completeness of VirtualBox 5 on NOVA
============================================

We updated our Virtualbox 5 port to 5.1.22 and enabled missing features
like SMP support, USB pass-through, audio, guest additions features like
shared folders, clipboard and dynamic desktop resizing.

The configuration of VBox 5 stayed the same as for VBox4 on Genode - so mainly
the existing run scripts must be adjusted regarding the build and binary names.

Nim programming language
========================
; @emery

The in the previous release we were proud to debut a
[http://genode.org/documentation/release-notes/17.02#Linux_TCP_IP_stack_as_VFS_plugin plugable TCP/IP stack]
for the VFS library. This required an overhaul of the the Berkley sockets
and 'select' implementation within the POSIX runtime, but scrutiny of the
POSIX standard leaves us reluctant to endorse it as a network API.

We have committed to maintaining our own low-level "socket_fs" API but
we would not recommend using it directly in applications, nor would we
commit to creating a high-level, native API. An economic approach would
be to support existing network libraries, or one step further, support
existing high-level languages with well integrated standard libraries.

One such language would be [https://nim-lang.org/ Nim]. This release adds
supports for Nim targets to the build-system and the Nim 0.17 release adds
Genode support to the Nim runtime. Nim supports compilation to C++ which
yields high integration at a low maintenance cost, and a full-featured
standard library that supports high-level application programming. Nim
features an intuitive asynchronous socket API for single-threaded applications
that abstracts the POSIX interface offered by the Genode C runtime.
This has the benefit of easing high-level application development while
supplying additional test coverage of the low-level runtime.

If Nim proves to be well suited to Genode then further topics of development
will be support for the Nimble package manager, including Genode signals in
Nim event dispatching, and replacing POSIX abstractions with a fully native
OS layer.


Qt5 updated to version 5.8
==========================

We updated our Qt5 port to version 5.8. In the process, we removed the use
of deprecated Genode APIs, which has some implications for Qt5 application
developers, as some parts of Qt5 now need to be initialized with the Genode
environment:

* Qt5 applications with a 'main()' function need to link with the new
  'qt5_component' library instead of the 'posix' library.

* Qt5 applications implementing 'Libc::Component::construct()' must
  initialize the QtCore and QtGui libraries by calling the
  'initialize_qt_core(Genode::Env &)' and 'initialize_qt_gui(Genode::Env &)'
  functions.

* Qt5 applications using the 'QPluginWidget' class must implement
  'Libc::Component::construct()' and call 'QPluginWidget::env(Genode::Env &)'
  in addition to the QtCore and QtGui initialization functions.


Platforms
#########

Execution on bare hardware (base-hw)
====================================
; @skalk

commit ede15967109c04f92bc9750547539e0e50ac80ca
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Tue Feb 21 13:46:59 2017 +0100

    hw: separate bootstrap and core strictly
    
    * Introduce Hw namespace and library files under src/lib/hw
    * Introduce Bootstrap namespace
    * Move all initialization logic into Bootstrap namespace
    
    Ref #2388

commit 074a58db50d49de8a8ba8a5e943640411a847672
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Wed Apr 12 10:06:29 2017 +0200

    hw: remove core internal header directories
    
    Fix #2393

commit 37ee0682830ae6ab9c9eac26c4c606d89b8d0da7
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Apr 28 15:27:26 2017 +0200

    base: remove include/spec/* other than ISA
    
    This commit moves the headers residing in `repos/base/include/spec/*/drivers`
    to `repos/base/include/drivers/defs` or repos/base/include/drivers/uart`
    respectively. The first one contains definitions about board-specific MMIO
    iand RAM addresses, or IRQ lines. While the latter contains device driver
    code for UART devices. Those definitions are used by driver implementations
    in `repos/base-hw`, `repos/os`, and `repos/dde-linux`, which now need to
    include them more explicitely.
    
    This work is a step in the direction of reducing 'SPEC' identifiers overall.
    
    Ref #2403


Muen separation kernel update
=============================

The Muen Separation Kernel port has been brought up to date. Most relevant to
Genode are the build system adaptations which enable smoother integration with
the Autopilot testing infrastructure.

Aside from this change, other features include support for xHCI debug, addition
of Lenovo x260 and Intel NUC 6i7KYK hardware configurations, support for Linux
4.10 and many other improvements.


Fiasco.OC kernel update
=======================
; @skalk

commit 4bfdbd34dae18f135443c2c51eae44fd805a1a7b
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon May 8 13:08:52 2017 +0200

    foc: remove obsolete features (ref #2405)
    
    Removes the following Fiasco.OC specific features:
    * GDB extensions for Fiasco.OC
    * i.MX53 support for Fiasco.OC
    * Kernel debugger terminal driver
    * Obsolete interface Native_pd
    * Obsolete function of interface Native_cpu


Tool chain
##########

GNU compiler collection (GCC) 6.3
=================================
; @cproc

commit 890317953724d8beb3f0924e887553cab8cb1cc2
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Fri Mar 17 13:10:55 2017 +0100

    tool_chain: use port mechanism
    
    Fixes #2340

commit 7cde6ac89ab616706c4816150009dfd9c8f4e204
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Sun Apr 9 21:02:29 2017 +0200

    binutils: update to version 2.28
    
    Fixes #2401
    Issue #2372

commit 5c5696be173292c22b7c70efd79a1d23602e31e8
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Sun Apr 9 21:02:34 2017 +0200

    gcc: update to version 6.3.0
    
    Issue #2372

commit b6162b65581fcea677c82cd5f1b4fa1744e8a44c
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Sun Apr 9 21:02:41 2017 +0200

    stdcxx: update to version 6.3.0
    
    Issue #2372

commit e18ded3a4edf19ec428c84d8ae83a58074ca7541
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Wed May 3 15:40:44 2017 +0200

    gcc: RISC-V 6.3.0
    
    issue #2423


Improved support for the Ada programming language
=================================================
; @cproc


Chain-boot loader for gzip-compressed boot modules
==================================================
; @skalk

commit 79143f67820000740a362211d9424f0adea32b91
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon Mar 27 12:39:13 2017 +0200

    tool/boot: add chain_loader 'unzip'
    
    'unzip' can uncompress and load raw multiboot images and ELF files.
    
    Usage together with the PXE bootloader ease life running the muen hypervisor
    together with a Genode/x86_64 VM, where the raw boot image is typically quite
    large.
    
    Ref #2358


Separated debug versions of built executables
=============================================

The _<build-dir>/bin/_ directory used to contain symbolic links to the
unstripped build results. However, since the new depot tool introduced with
Genode's package management extracts the content of binary archives from
_bin/_, the resulting archives would contain overly large unstripped binaries,
which is undesired. On the other hand, unconditionally stripping the build
results is not a good option either because we rely of symbol information
during debugging.

For this reason, build results are now installed at a new 'debug/' directory
located aside the existing 'bin/' directory. The debug directory contains
symbolic links to the unstripped build results whereas the bin directory
contains stripped binaries that are palatable for packaging (depot tool) and
for assembling boot images (run tool).


