

              ===============================================
              Release notes for the Genode OS Framework 16.05
              ===============================================

                               Genode Labs



; intro
; -> @nfeske

; XXX where to announce the updated book?


The great API renovation
########################

Genode's base API evolved over the years. When we started in 2006, our mindset
was very much influenced by L4, which regarded synchronous IPC as the only
mechanism needed. We used to implement components ("servers") in a procedural
programming style with a fully synchronous control flow within the component
and across components (IPC).

We eventually realized that the restriction to synchronous IPC was misguided.
(see  Section 3.6.2. "Asynchronous notifications" in
[http://genode.org/documentation/genode-foundations-16-05.pdf - the Genode Foundations book]
for a detailed discussion of the problems)
When we started to embrace the use of asynchronous
notifications and to disregard blocking RPC between components, we found
ourselves designing components as state machines rather than procedural
programs. To promote this programming style, we introduced the so-called
server API (os/server.h). See
[https://github.com/genodelabs/genode/blob/master/repos/os/src/server/nic_loopback/main.cc - NIC loopback server]
for a canonical example of such a component.

We found that this new style greatly increased the robustness and flexibility
of the components. In particular, it completely alleviates race conditions,
which constantly troubled us in the past. Now, following the new paradigm, we
may end up on a deadlock, but such a situation is easy to debug compared to
sporadic race conditions. Over the past two years we have redesigned all
Genode session interfaces to avoid blocking RPC. The only remains are the
parent and root interfaces, which we still need to address.

Still, the Genode API retained compatibility to the old (= wrong) style of
developing components. We take the current release as an opportunity to
finally clean the API from our past mistakes.


High-level overview of the changes
==================================

Removal of side effects
-----------------------

Up to now, most components rely on the globally available 'Genode::env()'
singleton object for interacting with its environment. When calling a function
or method, one never knows for sure if the called code interacts with the
'env'. E.g., we can simply create an instance of 'Timer::Connection' without
any arguments. Under the hood, the 'Connection' object accesses the 'env' to
open a timer session at the parent. In the spirit of capability-based
security, we should shun the reliance on side effects like the global 'env'.
Instead, we should pass all materials that are needed by the called code
explicitly to the called code (e.g., by passing a reference to a 'Parent &' as
argument. This way, someone inspecting the calling code can immediately see
the possible reach of the called code. Another prominent example is the latent
use of 'env()->heap()', which allows any code to arbitrary consume memory.
Instead, we should better pass an 'Allocator &' to the called code. This way,
we re-enforce that library code stays clean from the policy where memory is
allocated from. If no 'Allocator &' is passed, we know that no dynamic memory
allocation is performed. If an 'Allocator &' is required, the called code
needs to explain (in the form of its documentation) why the allocator is
actually needed. Moreover, by passing an 'Allocator_guard', the calling code
can impose a limit of the memory consumption on the called code.

Granted, the explicit passing of such arguments may lead to slightly more
verbose code. But this minor inconvenience is greatly outweighed by
the benefits of alleviating side effects.


Component API
-------------

Traditionally, components started their execution at a 'main' function
because, well, this is how it's supposed to be, right? The program exits as
soon as main returns. With the introduction of the server API mentioned above,
we explored a with different approach: The execution of a component starts at a
'construct' function that takes a form of the Genode environment as argument.
The function is expected to initialize the component. Upon completion of the
initialization, the function returns. Now, the component is ready to respond
to incoming RPC requests or signals. Each time such a request/signal comes in,
a handler is executed. The handler applies the component-internal state
changes and returns immediately. No blocking call is performed. We have
essentially a state machine.

Over the past two years, we have applied this new approach to all new
components - to a great success. So it is time to promote this API to become
Genode's base API. The major benefits are:

* Servers become easier to develop as the API is much simpler.
  Previously, a server had to manually create a CAP connection and an RPC
  entrypoint. Now, each component has an entrypoint.

* Signals and RPC requests are handled in the context of the same thread,
  which alleviates the need for locking as long as the component is single
  threaded, which is actually the case for most components.

* The notion of 'Thread', 'Signal_receiver', 'Rpc_entrypoint' are no longer
  needed by the developer of a component. There is simply an 'Entrypoint',
  which is able to handle both RPC requests and signals.


Shunning pointers
-----------------

The Genode API has still a lot of places where pointers are taken as arguments
or exposed from objects. We didn't know better when we started with Genode.
Now we do. With the current release, we streamline the base API in this
respect. Just as one simple example, the 'Heap' used to take an RM-session
pointer and an RAM-session pointer as arguments. These should be references.
Pointers should be used only in situations where a nullptr is a reasonable
argument, or when dealing with string literals as 'char const *'.


We are not there yet
--------------------

Whereas finding an API that successfully strikes the balance between the
lowest possible API complexity and highest possibly flexibility is extremely
challenging, it is even more complicated to execute the transition from one
API to another. The order of steps must planned carefully and interim
solutions must be designed as migration paths. We hope that the current
release does not induce too much pain for the users of the framework. Wherever
we found a way to smoothen the migration path, we took it. But there are a few
disruptive changes that are explained in detail in Section [Base framework].

There are still a few loose ends that we will address in the subsequent
release, in particular the redesign of the parent interface to become
completely asynchronous.


API migration guide
===================

In the current release we promote the former "server API" to the general
"component API", which should solely be used for new components. The old API
is now considered as deprecated. This short guide provides the list of the
steps one has to take to adapt an existing server-API-style component to the
new API.

The steps are as follows:

# Replace include directives

  The 'Server' namespace is superseded by the 'Component' namespace and the
  'Entrypoint' class has moved to the Genode namespace. Therefore, instead
  of including the _os/server.h_ header, the _base/component.h_ header must
  be included.

# Replace server definition

  Where the old API used the Server hook functions

  !char const *Server::name()                    { return "server_ep";         }
  !size_t      Server::stack_size()              { return 8*1024*sizeof(long); }
  !void        Server::construct(Entrypoint &ep) { static Main main(ep);       }

  the new API uses the Component hook functions

  !size_t Component::stack_size()                { return 8*1024*sizeof(long); }
  !void   Component::construct(Genode::Env &env) { static Main main(env);      }

  Note that the 'name()' function ceased to exist.

# Use 'Env' reference

  Whereas the old API passes a reference to an 'Entrypoint', the new API
  passes a reference to the 'Genode::Env' to the component's 'construct'
  function.
  The initial entrypoint of the component can be accessed through the 'Env'
  reference by calling the 'ep()' method. As intermediate step while doing the
  migration work, it is sufficient to call this method in the 'construct()'
  method, e.g.:

  !void Component::construct(Genode::Env &env) { static Main main(env.ep()); }

# Replace 'Signal_rpc_member'

  The 'Signal_rpc_member' class is considered deprecated and superseded by the
  'Signal_handler' class (see _base/signal.h_). Note that, the actual
  signal-handling method as passed to a 'Signal_handler' has no argument, as
  opposed to the old API where the handler was called with a counter value.

# Replace global 'Genode::env()' accessor

  The most cutting change is the discontinuation of the global 'Genode::env()'
  accessor function. Typically, this accessor was used throughout a component
  to access its environment, e.g. use 'Genode::env()->heap()' as allocator or
  'Genode::env()->rm_session()->attach()' to attach a dataspace.

  Since a component starts its life now at the execution of the 'construct'
  function, the component has to pass a reference to its 'Env' interface or
  rather a reference to the needed part of the 'Env' interface on. This
  explicit way of handling access to the component's environment will require
  the restructuring of the component. It is good practice to focus on the need
  at hand rather than to always pass the 'Env' reference on. On that account,
  it is important to note that the 'Rm_session' is no longer accessible and
  its place is taken by the 'Region_map'. Where one would have called
  'env()->rm_session()->attach' to attach a given dataaspace,
  'env.rm().attach' has now to be used.

  Furthermore, the global heap allocator object was removed. Components that
  want to use a heap like allocator have to create such an allocator
  manually:

  !Genode::Heap heap { &env.ram(), &env.rm() };

# Use new log facilities

  Instead of relying on the old print macros (PDBG, PERR, PINF, PLOG, PWRN)
  and thereby 'Genode::printf()', a component should use the new 'Log' class to
  produce diagnostic LOG output. There are a few convenient template functions,
  namely 'Genode::error()', 'Genode::log()' and 'Genode::warning()' that can be
  used. Note that these functions do not use a format string to print various
  different data types but just a list arguments, e.g.:

  !int const      i = 42;
  !char const * str = "world";
  !Genode::log("Hello ", str, "! ", i);

  produces 'Hello world! 42'.

  Note that certain datatypes, e.g. 'enum' and 'char', might have to be
  casted, e.g.:

  !enum { FOO, BAR };
  !Genode::log("enum: ", (int)FOO, " ", (int)BAR);


Base framework
##############

; -> @nfeske


New component API
=================



commit 4f69772ecca4cdb03d330cb3709c7e1e35607f8e
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Apr 27 22:11:38 2016 +0200

    Replace 'Env' interface with modern one
    
    The original 'Env' interface as returned by 'Genode::env()' has been
    renamed to 'Env_deprecated' and moved to deprecated/env.h. The new version
    of base/env.h contains the interface passed to modern components that
    use the component API via base/component.h.
    
    Issue #1832

commit 051e84c4b47f89b0d321147ec01cd0cee4e0961c
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Dec 23 15:22:33 2015 +0100

    Move server API concept to base framework
    
    This commit introduces the new `Component` interface in the form of the
    headers base/component.h and base/entrypoint.h. The os/server.h API
    has become merely a compatibilty wrapper and will eventually be removed.
    The same holds true for os/signal_rpc_dispatcher.h. The mechanism has
    moved to _base/signal.h_ in the form of the 'Signal_handler' class
    template.
    
    Issue #1832

commit 73b463cdbb6d8aeb89eff8fa371f519d493e91bf
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Apr 20 23:22:12 2016 +0200

    Signal_handler: remove num argument from handler
    
    We will eventually remove the delivery of the number of occurred signals
    to the recipient. There haven't been any convincing use cases for this
    feature. In the contrary, it actually led to wrong design choices in the
    past where the rate of signals carried information (such as the progress
    of time) that should better be obtained via an explicit RPC call.
    
    The old 'Signal_rpc_member' template retains the old interface for now.
    But the new 'Signal_handler' omits the 'unsigned' argument from the
    handler function.

commit a7b3072cc2120434a201eca019c743539de23cfa
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Tue May 10 17:24:51 2016 +0200

    Pass Env & as first argument to connection objects
    
    This patch supplements each existing connection type with an new
    constructor that is meant to replace the original one. The new
    one takes a reference to the component's environment as argument and
    thereby does not rely on the presence of the globally accessible
    'env()' interface.
    
    The original constructors are marked as deprecated. Once we have
    completely abolished the use of the global 'env()', we will remove them.
    
    Fixes #1960


Consolidation of core's SIGNAL, CAP, RM, and PD services
========================================================

commit b1910cdd54d77183bcce7cd7fb7594a0c4c5fa17
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Thu Jan 14 13:22:00 2016 +0100

    Integrate SIGNAL session into PD session
    
    This patch removes the SIGNAL service from core and moves its
    functionality to the PD session. Furthermore, it unifies the PD service
    implementation and terminology across the various base platforms.
    
    Issue #1841

commit 62b1c55399d6dc1b59548e542b35751ff2a3f425
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Tue Jan 19 20:24:22 2016 +0100

    Integrate CAP session into PD session
    
    This patch integrates the functionality of the former CAP session into
    the PD session and unifies the approch of supplementing the generic PD
    session with kernel-specific functionality. The latter is achieved by
    the new 'Native_pd' interface. The kernel-specific interface can be
    obtained via the Pd_session::native_pd accessor function. The
    kernel-specific interfaces are named Nova_native_pd, Foc_native_pd, and
    Linux_native_pd.
    
    The latter change allowed for to deduplication of the
    pd_session_component code among the various base platforms.
    
    To retain API compatibility, we keep the 'Cap_session' and
    'Cap_connection' around. But those classes have become mere wrappers
    around the PD session interface.
    
    Issue #1841

commit 511acad5074878bbaae46ae0aebab1b52fbb97b1
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Fri Apr 15 15:19:22 2016 +0200

    Consolidate RM service into PD session
    
    This patch integrates three region maps into each PD session to
    reduce the session overhead and to simplify the PD creation procedure.
    Please refer to the issue cited below for an elaborative discussion.
    
    Note the API change:
    
    With this patch, the semantics of core's RM service have changed. Now,
    the service is merely a tool for creating and destroying managed
    dataspaces, which are rarely needed. Regular components no longer need a
    RM session. For this reason, the corresponding argument for the
    'Process' and 'Child' constructors has been removed.
    
    The former interface of the 'Rm_session' is not named 'Region_map'. As a
    minor refinement, the 'Fault_type' enum values are now part of the
    'Region_map::State' struct.
    
    Issue #1938

commit b49e588c1cabd11d0433fd686d79b7c8c3e5bbbf
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Apr 20 21:12:57 2016 +0200

    Assign threads to PD at its creation time
    
    This patch replaces the former 'Pd_session::bind_thread' function by a
    PD-capability argument of the 'Cpu_session::create_thread' function, and
    removes the ancient thread-start protocol via 'Rm_session::add_client' and
    'Cpu_session::set_pager'. Threads are now bound to PDs at their creation
    time and implicitly paged according to the address space of the PD.
    
    Note the API change:
    
    This patch changes the signature of the 'Child' and 'Process' constructors.
    There is a new 'address_space' argument, which represents the region map
    representing the child's address space. It is supplied separately to the
    PD session capability (which principally can be invoked to obtain the
    PD's address space) to allow the population of the address space
    without relying on an 'Pd_session::address_space' RPC call.
    Furthermore, a new (optional) env_pd argument allows the explicit
    overriding of the PD capability handed out to the child as part of its
    environment. It can be used to intercept the interaction of the child
    with its PD session at core. This is used by Noux.
    
    Issue #1938

; * removed: cap_session/cap_session.h
; * deprecated: cap_session/connection.h


New log-output facilities
=========================

Throughout Genode, we used to rely on C-style format strings for the output of
diagnostic information and for the assembly of strings. There are many
drawbacks of this approach such as the limitation of the printable types to
the built-in format-string specifiers, the lack of type safety, and the
mismatch between the implementation of the intuitive expectations by the API
users.

With the current release we introduce the new log-output facility _base/log.h_
that will ultimately replace the original set of convenience macros PDBG,
PWRN, PERR, PINF by C++ function templates using variadic template arguments.
The function templates are plainly called 'log', 'error', and 'warning'
residing in the 'Genode::' namespace. The replacement for 'PDBG' must be a
macro in order to encode the calling function name into the string. As of now,
this functionality is not yet covered by _base/log.h_.

The header _base/output.h_ contains the mechanics for extraction a textual
representation from values and object instances. It provides the abstract
'Output' interface to be implemented by a consumer of text.
Functions for generating output for different types are named 'print' and
take an 'Output &' as first argument. The second argument is a 'const &'
to the value to print. Overloads of the 'print' function for commonly
used basic types are readily provided. Furthermore, there is a function template
that is used if none of the type-specific overloads match. This function
template expects the argument to be an object with a 'print' method. In
contrast to a plain 'print' function overload, such a method is able
to incorporate private state into the output.

The component's execution environment provides an implementation of the
'Output' interface that targets a LOG session. This output back end is
offered to the component in the form of the 'log', 'warning', and 'error'
functions that accept an arbitrary number of arguments that are printed
in a concatenated fashion. Each messages is implicitly finalized with a
newline character.

:deprecated _base/printf.h_, _base/console.h_, and _base/snprintf.h_:

  The goal of the new output facilities is the complete removal of format
  strings from the Genode API. Hence, the listed headers should be
  avoided.


XML processing
==============

Since the first version, Genode's init component relied on a configuration
in an XML-like syntax. For a long time, however, we remained hesitant to make the base system
(core and the base API) inherently dependent on XML. For the most part,
this hesitance was founded on our observation that XML tends to be disliked
in systems-programmers circles. However, over the years, XML organically became the
predominant syntax for component configurations as well as for the propagation
of state between components. Whereas the syntactical merits of XML are
highly subjective and perhaps debatable, the beauty of using XML within
Genode lies in its consistent application. For example, it allows us
naturally to embed component configurations in another component's
configuration. Much of Genode's flexibility that we enjoy today can be
attributes this coherency. Granted, this argument would apply just as well
to alternatives such as JSON or s-expressions. But we have to take one choice
and stick to it.
While we found that XML satisfies our needs and actually never stands
in the way, the impact on the code complexity is negligibly. Our XML parsing
and generating utilities are in the order of 700 lines of code.

With this perspective, we take the deliberate decision to make XML mandatory
for even the lowest-level parts of the framework. For example, even the
dynamic linker obtains the policy for diagnostic output from an XML-formatted
configuration. Consequently, we moved the XML utilities to
_base/include/util/_.

To ease the use it the XML parsing utilities, we also added the accessors
'Xml_node::type' and 'Xml_attribute::name' that return 'Genode::String'
objects.

:changed constructor of 'Reporter':

  One prominent use of XML is the reporting of state information from
  components to a report service. Most components facilitate the
  'Genode::Reporter' for this job. Originally, the report name is used
  implicitly as the top-level XML node type of the report.  This is inconvenient
  if one component wants to generate various XML reports under various names
  (e.g., to steer consumers/clients slightly differently) but with the same XML
  node tree structure. To accommodate those needs, the 'Reporter' now takes XML
  node type and the report label as two distinct arguments.


Dataspace helpers
=================

The use of dataspaces, e.g., for setting up shared memory between components,
involves typical sequences of operations. The 'Attached_*_dataspace'
utilities located at _os/include/os/_ take care of these technicalities.
With the current release, we promote them to be part of the base API and
thereby can leverage those utilities even for the lowest-level
components and internally. On that account, the corresponding header
files were moved to _base/include/base/_.

:changed constructors of 'Attached_*_dataspace' utilities:

  Originally, the dataspace utilities relied on side effects via the
  'Genode::env()' accessor. To break away from this bad practice, the
  new versions have constructors that take all needed resources as explicit
  arguments. The original constructors are scheduled for removal.

The most common use case of 'Attached_rom_dataspace' is the consumption
of XML-formatted data. To accommodate this common pattern, we equipped
the 'Attached_rom_dataspace' with an accessor plainly named 'xml'.
It always returns a valid 'Xml_node' even in the event
where the dataspace is invalid or contains no XML. In such cases, the returned
XML node is '<empty/>'. This way, we spare the caller the handling of the
exceptions that may occur during the XML parsing.
Now a configuration attribute can be obtained as follows:

!Genode::Attached_rom_dataspace config(env, "config");
!...
!bool const verbose = config.xml().attribute_value("verbose", false);

:deprecated _os/config.h_:

  Since it has become so easy to consume XML ROM sessions, the role of the
  former 'Genode::config()' interface has become largely obsolete. In line
  with our goal to eliminate global side effects, the _os/config.h_ has
  become deprecated.


Thread API and CPU-session interface
====================================

commit 7f73e5e879a748b21c795094f96d0aef2d4487ab
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Sat Jan 23 14:42:55 2016 +0100

    base: hide internals of the Thread API
    
    This patch moves details about the stack allocation and organization
    the base-internal headers. Thereby, I replaced the notion of "thread
    contexts" by "stacks" as this term is much more intuitive. The fact that
    we place thread-specific information at the bottom of the stack is not
    worth introducing new terminology.
    
    Issue #1832

commit fd401bdf53e1cc6841f0f22f45b7b04444e81dfd
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed May 4 12:27:17 2016 +0200

    Thread API cleanup
    
    This patch cleans up the thread API and comes with the following
    noteworthy changes:
    
    - Introduced Cpu_session::Weight type that replaces a formerly used
      plain integer value to prevent the accidental mix-up of
      arguments.
    - The enum definition of Cpu_session::DEFAULT_WEIGHT moved to
      Cpu_session::Weight::DEFAULT_WEIGHT
    - New Thread constructor that takes a 'Env &' as first argument.
      The original constructors are now marked as deprecated. For the
      common use case where the default 'Weight' and 'Affinity' are
      used, a shortcut is provided. In the long term, those two
      constructors should be the only ones to remain.
    - The former 'Thread<>' class template has been renamed to
      'Thread_deprecated'.
    - The former 'Thread_base' class is now called 'Thread'.
    - The new 'name()' accessor returns the thread's name as 'Name'
      object as centrally defined via 'Cpu_session::Name'. It is meant to
      replace the old-fashioned 'name' method that takes a buffer and size
      as arguments.
    - Adaptation of the thread test to the new API
    
    Issue #1954

commit 0c299c5e08b8ff4d19697283307446ca0f0e2644
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Wed Mar 30 15:34:37 2016 +0200

    base: separate native CPU from CPU session
    
    This patch unifies the CPU session interface across all platforms. The
    former differences are moved to respective "native-CPU" interfaces.
    
    NOVA is not covered by the patch and still relies on a custom version of
    the core-internal 'cpu_session_component.h'. However, this will soon be
    removed once the ongoing rework of pause/single-step on NOVA is
    completed.
    
    Fixes #1922

commit a99989af40876d01307ab4745bdc3b9fdfed65bd
Author: Norman Feske <norman.feske@genode-labs.com>
Date:   Tue May 10 18:05:38 2016 +0200

    Separation of thread operations from CPU session
    
    This patch moves the thread operations from the 'Cpu_session'
    to the 'Cpu_thread' interface.
    
    A noteworthy semantic change is the meaning of the former
    'exception_handler' function, which used to define both, the default
    exception handler or a thread-specific signal handler. Now, the
    'Cpu_session::exception_sigh' function defines the CPU-session-wide
    default handler whereas the 'Cpu_thread::exception_sigh' function
    defines the thread-specific one.
    
    To retain the ability to create 'Child' objects without invoking a
    capability, the child's initial thread must be created outside the
    'Child::Process'. It is now represented by the 'Child::Initial_thread',
    which is passed as argument to the 'Child' constructor.
    
    Fixes #1939


Child management
================

The 'Child' class has been adapted to the changed core services and partially
redesigned to enable the implementation of single-threaded runtime
environments that virtualize the CPU, PD, and RAM services. It thereby has
become free from side effects. I.e., instead of implicitly using
'Genode::env()->rm_session()', it takes the reference to the local region map
as argument. Also, the handling of the dynamic linker via global variables is
gone. Now, the linker binary must be provided as constructor argument.


Stylistic changes
=================

:'Heap', 'Sliced_heap', 'Root_component':

  We added new constructors to these classes that take references, not
  pointers, as arguments. The old constructors will be removed with the
  next release.

:Naming of boolean getter methods:

  We already follow a convention about the naming of accessor methods (not
  using any get_ or set_ prefixes). However, we sometimes used an "is_" prefix
  for getter functions of boolean values, but not always. Examples are
  'Capability::valid()' and 'Weak_ptr::is_valid()'.

  In the name of the principle of least surprise, we introduced the convention
  to not use an "is_" prefix for such methods. We adjusted all occurrences
  within the Genode code base accordingly. To maintain API compatibility
  during the transitional phase, keep the original methods until the next
  release.

:Alleviating the need for manually constructed type lists:

  The 'GENODE_RPC_INTERFACE' macro of the RPC framework had a limitation
  with respect to the number of RPC functions per RPC interface. As a
  workaround for this limitation, large session interfaces had to manually
  define the type list of RPC functions out of nested type tuples. With the
  current release, we removed the limitation.


Removed and to-be-removed APIs
==============================

:removed _base/crt0.h_ and _base/elf.h_:

  Those headers are internally needed by the framework but contain no
  actual value at the API level. Therefore we removed them from the
  public API.

:removed _base/process.h_:

  The 'Process' class encapsulated the platform-specific steps to start
  a Genode component with a given ELF file. The original intention of
  placing this low-level mechanism into a dedicated class was to allow
  for different flavours it child-management policies. In practice, however,
  the 'Process' remained solely being used by the 'Genode::Child'. Since
  the core-interface changes of Section
  [Consolidation of core's SIGNAL, CAP, RM, and PD services]
  required us to rewrite the component-creation code anyway and we aspire to
  narrow the API, we took the chance make 'Process' private to the 'Child'.
  The rather ambiguous term "process", which we avoid in the context
  of Genode by speaking of "components" instead, is eliminated from the public
  API.

:discourage use of _util/arg_string.h_:

  The 'Arg_string' utilities are used to generate and parse session-argument
  strings. However, to make Genode more coherent and session arguments more
  flexible and robust, we plan to replace the current argument-string
  syntax with XML, eventually removing the argument-string support. Hence,
  we discourage the use of 'util/arg_string.h'.

:discourage use of _base/signal.h_:

  The introduction of the new 'Entrypoint' eliminates the need to manually
  create and use 'Signal_receiver'. Right now, we still rely on the original
  signal API as backend of the 'Entrypoint' but we will eventually remove
  the current notion of signal receivers. The narrower semantics of the
  'Entrypoint' will then allow for performance optimizations that are not
  possible with the traditional signal receivers. Therefore, we discourage
  the direct use it 'Signal_receiver'.


Low-level OS infrastructure
###########################

Enhanced GDB support on NOVA
============================

During the practical work with the GDB monitor (our Genode port of the GNU
'gdbserver' application) and our nightly automated execution of the
'gdb_monitor.run' test, it turned out that there are still situations which
GDB monitor cannot handle correctly. Since the error symptoms often occur only
sporadically and it is often not obvious if the cause of the error is located
in the Genode-specific adaptations of the gdbserver code or in the platform-
specific functionality of the Genode base system, a first step to improve the
stability of the debugger was to try to remove existing Genode-specific code
from the gdbserver codebase and to emulate the Linux-specific C interface
instead, which especially involved a GDB monitor-local implementation of the
'waitpid()' function. This interface is documented relatively well and in the
case of error there would be a better chance of comparing the GDB monitor-
internal execution sequence with a corresponding test case on the Linux version
of gdbserver.

The emulation of this interface is not trivial, though, because the behavior of
the Linux kernel often differs from the behavior of the Genode base components.
For example, when debugging a Linux program, a new thread created by the
debug target gets stopped automatically by the Linux kernel and the 'waitpid()'
function reports a SIGSTOP signal for the new thread and a SIGTRAP signal for
the creating thread to the gdbserver. This behavior does not match at all with
the design of the Genode base system, so it gets emulated in the GDB monitor
with the help of a software breakpoint on the first instruction of the new
thread and the artificial creation of the corresponding SIGSTOP and SIGTRAP
signal reports.

While implementing this mechanism in the
'Gdb_monitor::Cpu_thread_component::start()' method, it turned out that on the
NOVA platform on the creation of a so-called 'local thread' (a NOVA thread
which only responds to IPC and has no execution time of its own), the initial
instruction pointer passed to the function was always 0. So, changes in the
NOVA base system were necessary to get to know the correct start address
of the thread in order to set a breakpoint there. Another problem was found to
be that an attempt by GDB monitor to pause a thread of the debug target could
block for quite some time if the particular thread was currently blocking in a
NOVA syscall. In that case, the 'Cpu_thread::pause()' call returned only after
the particular thread got executed in userland again, because only then the
current register state of the thread could be transferred into userland for
retrieval by GDB. This problem got solved by an extension of the NOVA kernel,
which makes it possible to get the current register state of a to-be-paused
thread immediately most of the time.

Furthermore, the NOVA-specific changes for GDB make it possible for GDB to
modify register values and to debug 64-bit applications.

As reference, the 'ports/run/gdb_monitor.run' script demonstrates and tests a
selection of the features supported by GDB on Genode.


New support for the Rust programming language
=============================================

[https://www.rust-lang.org/ - Rust] is a systems programming language that
currently gains a lot of popularity. It eliminates entire classes of bugs by
enforcing memory safety. Unlike languages that rely on a garbage-collecting
runtime, compiled Rust programs are able to run on bare-metal hardware. This
makes Rust an attractive language for low-level system components.

The current Genode release introduces basic support for executing
Rust programs as Genode components. This support includes the
build-system integration, the configuration of the llvm-based Rust
compiler, and the port of the low-level language runtime. A simple example is
provided via the _libports/run/rust.run_ script and the accompanied code at
_libports/src/test/rust/_. The example runs on the x86 (32 and 64 bit) and
ARM architectures.

Thanks to Waylon Cude for bringing Rust to Genode!


Dynamic linker
==============

; XXX should we keep this section?

The dynamic linker will now check if the binary pointer is valid before
attempting to lookup a symbol. Shared objects with unresolved symbols and
missing dependencies, e.g. a library that references 'errno' but is not linked
against libc, will now produce an error message when they are loaded by the
dynamic linker instead of triggering a ominous page-fault.


New component for writing ROM modules to files
==============================================

The rom-to-file component at _repos/os/src/app/rom_to_file_ requests a ROM
session and writes the content of the ROM dataspace to a file of a file-system
session. It is able to respond to configuration and ROM-module updates. The
name of the ROM module must be specified via the 'rom' attribute of the
components '<config>' node:

! <config rom="pointer"/>

See _run/rom_to_file.run_ for an example.

Thanks to Johannes Schlatow for this contribution!


C runtime
=========

; -> @chelmuth

commit 93b82c14ac3cd39fda84f6cc61dfab019456cb60
Author: Emery Hemingway <emery@vfemail.net>
Date:   Fri Apr 15 14:19:51 2016 +0200

    libc: read sysctl info from /.sysctl/...
    
    Fixes #1931


libc_pipe plugin
~~~~~~~~~~~~~~~~

The new 'libc_pipe' plugin provides a more accurate implementation of pipes
(using a ring buffer) and replaces the existing 'libc_lock_pipe' plugin.


Device drivers
##############

In this release we did update several device drivers that are ported from
forgein OS'. In addition, we consoldiated all drivers in the dde_linux
repository by utilizing the modular lx_kit and made sure that each driver
is using the same Linux version now.


HDA Audio driver update
=======================

The audio driver was synced with version 5.9 of OpenBSD. In addition to
updating the contrib sources the driver now uses the new Component API
and will report the internal mixer state.

Reporting of the mixer state is enabled by adding the 'report_mixer'
attribute to the drivers configuration and setting its value to 'yes'.

The following snippets illustrates the format of the report:

!<mixer_state>
!  <mixer field="inputs.beep" value="108"/>
!  <mixer field="outputs.hp_sense" value="plugged"/>
!  <mixer field="outputs.master" value="128,128"/>
!  <mixer field="outputs.mic_sense" value="unplugged"/>
!  <mixer field="outputs.spkr_muters" value="hp,mic"/>
!</mixer_state>

The mixer state can expose other mixer fields as well, depending on the
used hardware. The naming scheme of the attributes intentionally matches
the naming scheme of OpenBSD's mixerctl(1) program.

In return, 'mixer' nodes may be used to configure the audio driver by
specifying it in the configuration, e.g.:

!<config report_mixer="yes">
!  <mixer field="outputs.master" value="255,255"/>
!</config>

will set the output volume to the highest possible value. Although it is
now also possible to update the configuration at run-time this should only
be done with care. Updating the configuration while the driver is playing
or recording may provoke audible artefacts. For now it is best to use the
mixer component to regulate the volume rather than adjusting the audio
driver directly.


Linux kit
=========

Over the years the way we handled our DDEs has changed. By now it became
clear that it is easier to manage ported drivers without having to rely an
generic API like dde_kit. Using Genode primitives directly enables us to
specially tailor each DDE to the driver in question. That being said,
when having four different drivers (intel_fb, lxip, usb and wifi) and each
has its own specially tailored DDE, the amount of redundant code is huge.
We created the lx_kit that enables us to share code across the drivers as
well as to provide specific pieces in each driver itself to address this
issue and eventually decrease the amount of redundant code.

This modular lx_kit seperates the required back end functionality of the
Linux emulation environment from the front end. Thereby each driver can
reuse generic parts and supply more suitable implementations by itself.
It is split into several layers whose structure is as follows:

The first layer in _repos/dde_linux/src/include/lx_emul_ contains those
header files that provide the structural definitions and function
declarations of the Linux API, e.g. _errno.h_ provides all error code
values. The second layer in _repos/dde_linux/src/include/lx_emul/impl_
contains the implementation of selected functions, e.g. _slab.h_
provides the implementation of 'kmalloc()'. The lx_kit back end API is
the third layer and provides the _Lx::Malloc_ interface
(_repos/dde_linux/src/include/lx_kit/malloc.h_) which is used to
implement 'kmalloc()'. There are several generic implementations of the
lx_kit interfaces that can be used by a driver.

A driver typically includes a 'lx_emul/impl/xyz.h' header once
directly in its lx_emul compilation unit. The lx_kit interface files
are only included in those compilation units that use or implement the
interface. If a driver wants to use a generic implementation it must
add the source file to its source file list. The generic
implementations are located in _repos/dde_linux/src/lx_kit/_.

The modular lx_kit still depends on the private _lx_emul.h_ header file
that is tailored to each driver. Since the lx_kit already contains much
of the declarations and definitions that were originally placed in
these private header files, those files can now ommit a large amount
of code.


Wifi driver update
==================

The wifi_drv was updated to Linux version 4.4.3 and thereby adds support for
Intel wireless card 8xxx series. In order to ease debugging the driver now
enables its debugging messages when the 'verbose' attribute in its 'config'
node is set to 'yes'.


USB driver update
=================

The USB driver was updated to Linux version 4.4.3 and like the other drivers
incorporates the modular lx_kit. The new driver exposed problems with the
EHCI controller on older systems, namely the Thinkpad X201. Using the new USB
driver on this machine would freeze the system when 'USB legacy Support' is
enabled in the BIOS. The fix is to apply the USB hand-off quirk, that informs
the BIOS that the OS wants to drive the USB host-controller and waits until
the BIOS has acknowledged the request. Unfortunatly, applying this quirk
produces problems on certain xHCI host-controllers when using the IOMMU. In
this case the driver tried to perform the hand-off request but got stuck while
writing to the PCI config space. After about 20 seconds we saw a DMA fault and
the initialization of the USB driver went on. Presumably at this point the BIOS
tries to access certain memory regions that by now are protected by the IOMMU.
When using the IOMMU, we already take precautions, i.e., we look at the RMRR
regions and instruct the kernel to configured the IOMMU for specific devices
accordingly. We looked at the ACPI RMRR region of the USB on the machine in
question and could confirm our suspicion: the registered USB RMRR region is
indeed too small. For all we know that sounds like a bug in BIOS or rather
ACPI tables. To accomodate systems that nonetheless need the hand-off quirk
and the user wants to use the IOMMU, we added the handling of a 'bios_handoff'
attribute to the USB driver configuration. When set to 'no' the driver will not
perform any hand-off request. The default setting is 'yes'. If you experience
any issues with the new USB driver, disabling the hand-off is advised.

While updating the driver a regression on the Raspberry Pi was introduced.
USB devices that use IRQ endpoints, e.g. USB HID devices, do not work
reliably. This issue is still unresolved and dealing with it is post-poned
until after the release.

Furthermore, the USB session used for implementing native USB device drivers
propagates an EP stall error to the client and clears the stall condition by
resetting the EP now.


Intel graphics driver update
============================

The Intel graphics driver introduced in Genode release 15.11 was updated to
Linux version 4.4.3. The most prominent, functional improvement is support for
Intel Skylake graphics cards.
Internally, we slimmed the code parts used from the Linux kernel by resigning
the ancient framebuffer and framebuffer console layer. The new driver only uses
the more modern DRM layer of the Linux kernel. As a side effect all formerly
available heuristics that were applied at initialization time, or whenever a
display got connected are not part of the driver anymore. Now, the driver only
reports any state changes like additional available displays via its report
session. On the other hand it always updates the graphics configuration whenever
its config ROM module changes.
To automatically control the graphics driver during display connection changes
an example component named intel_fb_controller is now available in:
_repos/dde_linux/src/test/framebuffer/intel_. This component reacts on report
changes of the Intel graphics driver and configures it in a way that all
available displays are showing one and the same framebuffer with their maximum
resolution. Thereby displays with a minor resolution show the upper left corner
of the whole framebuffer.


Enhanced ACPI support
=====================

; -> @alexab
; XXX should we move this topic to a top-level section?

commit ce36b560a60ab257a4c09539b49c39879814b860
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Fri May 13 15:52:34 2016 +0200

    acpi_drv: report ACPI reset configuration
    
    Will be/can be used by the platform driver to reset the machine, iif the
    platform driver owns the resources, e.g. the I/O ports of PCI config access.
    
    Issue #1962

commit 2ee123872e5a32d304854ef55c5bf896ede88ddd
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Fri Mar 18 16:31:00 2016 +0100

    libports: add acpica library
    
    Fixes #1962

commit 2221df4fff20e3a8fea7dcffa889eea0ffb2f974
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Fri May 13 16:09:20 2016 +0200

    platform_drv/x86: support ACPI reset
    
    Evaluate fadt xml node in report from acpi_drv. If the io ports in the range
    of 0xcf8+4 are necessary for the reset than the platform driver will
    react on the 'system' state 'reset' and reboot.
    
    Issue #1962


Generalized SDHCI driver
========================

The SDHCD driver was originally creates for the Raspberry Pi. However, the
same host controller is used also in other platforms, in particular Xilinx
Zynq. Hence, the existing driver was generalized to become usable on such
platforms. Thanks to Timo Wischer for this contribution.


Libraries and applications
##########################

LxIP update
===========

LxIP is the port of the Linux TCP/IP stack as a library on Genode.
Along with the work described in Section [Linux kit], LxIP was updated to
Linux version 4.4.3 and uses the lx_kit now.


Qemu USB
========

; XXX should we keep this section or is the level of detail too much?

The QEMU USB library handles EP stalls now. In particular, this fix
enables the usage of USB devices in VirtualBox that do not support certain
SCSI commands, e.g. READ_FORMAT_CAPACITY, and will stall if they receive
such a command. Windows guests typically use the afor mentioned command to
check if the USB storage device in question is in fact an USB floppy drive.


Platforms
#########

Generalization of platform-specific headers
===========================================

In anticipation of the planned binary compatibility of Genode components
across different kernels, we unified most parts of Genode's base API and
largely removed the dependency on platform-specific types. The most profound
change is the interface of the IPC library, which used to depend on
platform-specific message-buffer layouts.
Besides unifying the message buffer classes across all platforms, we
reconsidered the roles of the IPC-library classes such as 'Ipc_marhsaller',
'Ipc_server', and 'Ipc_client'. This led to several further simplifications in
the server-loop implementations, which makes the flow of control and
information much more obvious, yet is also more flexible. I.e., on NOVA, we
don't even have the notion of reply-and-wait. Now, we are no longer forced to
pretend otherwise.


NOVA microhypervisor
====================

; -> @alexab

commit dccad4c526b7ea93f6a5b1d79138423518a2924c
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Thu Apr 28 13:38:21 2016 +0200

    nova: kernel support for more than 4096 processes
    
    Fixes #1951

commit 1622f53dd815804a9a64b0cd89a2f85c8427c9e0
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Thu May 12 12:53:17 2016 +0200

    nova: support fixed ACPI event delivery by kernel
    
    Issue #1962


Execution on bare hardware (base-hw)
====================================

For running Genode scenarios on our custom kernel (base-hw), two hardware
timers are needed. One timer is used by the kernel as the basis for the
preemptive scheduling. The other timer is used by the user-level timer
driver as the timing source for user-level components.

On NOVA, we gathered good experiences with using the kernel's scheduling
timer as the basis for the user-level timer. Eliminating the need for
a real timer device driver (like the PIT) reduces the overall complexity.
The interrupt load becomes lower without the userland triggering timer
interrupts. And since the kernel uses CPU-core-local timers (i.e. the
local APIC timer on x86) as opposed to a global timer in the userland,
expensive cross-CPU-communication is avoided.

With the current release, we applied the lessons learned to our base-hw
kernel. As a further motivation, the removal of the dependency on a
timer device clears the way to run multiple Genode instances on top of
the Muen separation kernel.

The timeout feature has the form of a new 'timeout' system call that binds
a signal context to a timeout. Hence, timeouts are delivered asynchronously,
like interrupts, to the user-level timer service. The actual time can be
requested via the 'timeout_age_us' system call, which returns the time
since the last timeout was installed.


Linux
=====

; -> @chelmuth

commit 14f1ac497efc9f4f1fa4d92f8a720e9a0be5403e
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Fri Apr 8 18:24:15 2016 +0200

    linux: improve exception-signal handling
    
    First, we use an alternate stack for signal handling now. The stack is
    shared among all threads of the component, which is okay as we only
    handle exceptions with log output and pass on to the default handler
    (that terminates the execution). The primary motivation for the
    alternate stack is the detection of SIGSEGV due to stack overflows.
    
    Also, hybrid components now handle exception signals by logging and the
    support for multi-threaded applications was improved.
    
    Fixes #1935


Tools and build system
######################

Usability improvements of the ports tools
=========================================

The ports tool set introduces in
[http://genode.org/documentation/release-notes/14.05#Management_of_ported_3rd-party_source_code - Genode 14.05]
has become an integral part of the workflow for Genode developers.
With the current release, we improve the usability of the _prepare_port_ tool
in two respects. First, the tool now accept a list of ports instead of
merely a single argument. This alleviates the need to manually re-execute
the tool with different arguments. Second, if the build system encounters
a missing port it no longer backs out immediately but collects all the
(potentially more than one) missing ports that are required for the build.
It then presents the user with a ready-to-use command to install all
missing ports at once, which greatly improves the experience of working with
sophisticated system scenarios. For example, when attempting to execute
the _virtualbox.run_ script with a freshly cloned Genode source tree,
the build system produces the following error message:

!Error: Ports not prepared or outdated:
!  dde_linux libc libiconv nova qemu-usb stdcxx virtualbox x86emu
!
!You can prepare respectively update them as follows:
!  .../prepare_port dde_linux libc libiconv nova qemu-usb stdcxx virtualbox x86emu

Additionally, one may state the number of ports that
shall be prepared in parallel at a max by using the -j parameter. If -j
is not set by the user, the tool acts as with -j1.

Since the _prepare_ports_ tool has completely replaced the former
"make prepare" mechanism, we finally removed the last traces of the old
mechanism in the form of the makefiles present in the respective source-code
repositories.


Updated tool chain
==================

; -> @chelmuth

We enabled the '__cxa_demangle()' function in our tool chain to be able to
print user-readable names of uncaught exceptions.

XXX tool chain update required
XXX added RISC-V
XXX GDB x86_64


Removal of stale features
#########################

We originally added chroot support to the Linux version of Genode to
accommodate the use of Genode as middleware on Linux. We enabled the
configuration of custom UIDs, GIDs, and chroot paths for components started by
init. However, apart from a brief period of time when we experimented with
the idea, it is no longer pursued. Now, with our aspiration to attain binary
compatibility across kernels, we removed the Linux-specific chroot support.
