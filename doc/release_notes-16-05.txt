

              ===============================================
              Release notes for the Genode OS Framework 16.05
              ===============================================

                               Genode Labs



; intro
; -> @nfeske

; XXX where to announce the updated book?


The great API renovation
########################

Genode's base API evolved over the years. When we started in 2006, our mindset
was very much influenced by L4, which regarded synchronous IPC as the only
mechanism needed. We used to implement components ("servers") in a procedural
programming style with a fully synchronous control flow within the component
and across components (IPC).

We eventually realized that the restriction to synchronous IPC was misguided.
(see  Section 3.6.2. "Asynchronous notifications" in
[http://genode.org/documentation/genode-foundations-16-05.pdf - the Genode Foundations book]
for a detailed discussion of the problems)
When we started to embrace the use of asynchronous
notifications and to disregard blocking RPC between components, we found
ourselves designing components as state machines rather than procedural
programs. To promote this programming style, we introduced the so-called
server API (os/server.h). See
[https://github.com/genodelabs/genode/blob/master/repos/os/src/server/nic_loopback/main.cc - NIC loopback server]
for a canonical example of such a component.

We found that this new style greatly increased the robustness and flexibility
of the components. In particular, it completely alleviates race conditions,
which constantly troubled us in the past. Now, following the new paradigm, we
may end up on a deadlock, but such a situation is easy to debug compared to
sporadic race conditions. Over the past two years we have redesigned all
Genode session interfaces to avoid blocking RPC. The only remains are the
parent and root interfaces, which we still need to address.

Still, the Genode API retained compatibility to the old (= wrong) style of
developing components. We take the current release as an opportunity to
finally clean the API from our past mistakes.


High-level overview of the changes
==================================

Removal of side effects
-----------------------

Up to now, most components rely on the globally available 'Genode::env()'
singleton object for interacting with its environment. When calling a function
or method, one never knows for sure if the called code interacts with the
'env'. E.g., we can simply create an instance of 'Timer::Connection' without
any arguments. Under the hood, the 'Connection' object accesses the 'env' to
open a timer session at the parent. In the spirit of capability-based
security, we should shun the reliance on side effects like the global 'env'.
Instead, we should pass all materials that are needed by the called code
explicitly to the called code (e.g., by passing a reference to a 'Parent &' as
argument. This way, someone inspecting the calling code can immediately see
the possible reach of the called code. Another prominent example is the latent
use of 'env()->heap()', which allows any code to arbitrary consume memory.
Instead, we should better pass an 'Allocator &' to the called code. This way,
we re-enforce that library code stays clean from the policy where memory is
allocated from. If no 'Allocator &' is passed, we know that no dynamic memory
allocation is performed. If an 'Allocator &' is required, the called code
needs to explain (in the form of its documentation) why the allocator is
actually needed. Moreover, by passing an 'Allocator_guard', the calling code
can impose a limit of the memory consumption on the called code.

Granted, the explicit passing of such arguments may lead to slightly more
verbose code. But this minor inconvenience is greatly outweighed by
the benefits of alleviating side effects.


Component API
-------------

Traditionally, components started their execution at a 'main' function
because, well, this is how it's supposed to be, right? The program exits as
soon as main returns. With the introduction of the server API mentioned above,
we explored a with different approach: The execution of a component starts at a
'construct' function that takes a form of the Genode environment as argument.
The function is expected to initialize the component. Upon completion of the
initialization, the function returns. Now, the component is ready to respond
to incoming RPC requests or signals. Each time such a request/signal comes in,
a handler is executed. The handler applies the component-internal state
changes and returns immediately. No blocking call is performed. We have
essentially a state machine.

Over the past two years, we have applied this new approach to all new
components - to a great success. So it is time to promote this API to become
Genode's base API. The major benefits are:

* Servers become easier to develop as the API is much simpler.
  Previously, a server had to manually create a CAP connection and an RPC
  entrypoint. Now, each component has an entrypoint.

* Signals and RPC requests are handled in the context of the same thread,
  which alleviates the need for locking as long as the component is single
  threaded, which is actually the case for most components.

* The notion of 'Thread', 'Signal_receiver', 'Rpc_entrypoint' are no longer
  needed by the developer of a component. There is simply an 'Entrypoint',
  which is able to handle both RPC requests and signals.


Shunning pointers
-----------------

The Genode API has still a lot of places where pointers are taken as arguments
or exposed from objects. We didn't know better when we started with Genode.
Now we do. With the current release, we streamline the base API in this
respect. Just as one simple example, the 'Heap' used to take an RM-session
pointer and an RAM-session pointer as arguments. These should be references.
Pointers should be used only in situations where a nullptr is a reasonable
argument, or when dealing with string literals as 'char const *'.


We are not there yet
--------------------

Whereas finding an API that successfully strikes the balance between the
lowest possible API complexity and highest possibly flexibility is extremely
challenging, it is even more complicated to execute the transition from one
API to another. The order of steps must planned carefully and interim
solutions must be designed as migration paths. We hope that the current
release does not induce too much pain for the users of the framework. Wherever
we found a way to smoothen the migration path, we took it. But there are a few
disruptive changes that are explained in detail in Section [Base framework].

There are still a few loose ends that we will address in the subsequent
release, in particular the redesign of the parent interface to become
completely asynchronous.


API migration guide
===================

In the current release we promote the former "server API" to the general
"component API", which should solely be used for new components. The old API
is now considered as deprecated. This short guide provides the list of the
steps one has to take to adapt an existing server-API-style component to the
new API.

The steps are as follows:

# Replace include directives

  The 'Server' namespace is superseded by the 'Component' namespace and the
  'Entrypoint' class has moved to the Genode namespace. Therefore, instead
  of including the _os/server.h_ header, the _base/component.h_ header must
  be included.

# Replace server definition

  Where the old API used the Server hook functions

  !char const *Server::name()                    { return "server_ep";         }
  !size_t      Server::stack_size()              { return 8*1024*sizeof(long); }
  !void        Server::construct(Entrypoint &ep) { static Main main(ep);       }

  the new API uses the Component hook functions

  !size_t Component::stack_size()                { return 8*1024*sizeof(long); }
  !void   Component::construct(Genode::Env &env) { static Main main(env);      }

  Note that the 'name()' function ceased to exist.

# Use 'Env' reference

  Whereas the old API passes a reference to an 'Entrypoint', the new API
  passes a reference to the 'Genode::Env' to the component's 'construct'
  function.
  The initial entrypoint of the component can be accessed through the 'Env'
  reference by calling the 'ep()' method. As intermediate step while doing the
  migration work, it is sufficient to call this method in the 'construct()'
  method, e.g.:

  !void Component::construct(Genode::Env &env) { static Main main(env.ep()); }

# Replace 'Signal_rpc_member'

  The 'Signal_rpc_member' class is considered deprecated and superseded by the
  'Signal_handler' class (see _base/signal.h_). Note that, the actual
  signal-handling method as passed to a 'Signal_handler' has no argument, as
  opposed to the old API where the handler was called with a counter value.

# Replace global 'Genode::env()' accessor

  The most cutting change is the discontinuation of the global 'Genode::env()'
  accessor function. Typically, this accessor was used throughout a component
  to access its environment, e.g. use 'Genode::env()->heap()' as allocator or
  'Genode::env()->rm_session()->attach()' to attach a dataspace.

  Since a component starts its life now at the execution of the 'construct'
  function, the component has to pass a reference to its 'Env' interface or
  rather a reference to the needed part of the 'Env' interface on. This
  explicit way of handling access to the component's environment will require
  the restructuring of the component. It is good practice to focus on the need
  at hand rather than to always pass the 'Env' reference on. On that account,
  it is important to note that the 'Rm_session' is no longer accessible and
  its place is taken by the 'Region_map'. Where one would have called
  'env()->rm_session()->attach' to attach a given dataaspace,
  'env.rm().attach' has now to be used.

  Furthermore, the global heap allocator object was removed. Components that
  want to use a heap like allocator have to create such an allocator
  manually:

  !Genode::Heap heap { &env.ram(), &env.rm() };

# Use new log facilities

  Instead of relying on the old print macros (PDBG, PERR, PINF, PLOG, PWRN)
  and thereby 'Genode::printf()', a component should use the new 'Log' class to
  produce diagnostic LOG output. There are a few convenient template functions,
  namely 'Genode::error()', 'Genode::log()' and 'Genode::warning()' that can be
  used. Note that these functions do not use a format string to print various
  different data types but just a list arguments, e.g.:

  !int const      i = 42;
  !char const * str = "world";
  !Genode::log("Hello ", str, "! ", i);

  produces 'Hello world! 42'.

  Note that certain datatypes, e.g. 'enum' and 'char', might have to be
  casted, e.g.:

  !enum { FOO, BAR };
  !Genode::log("enum: ", (int)FOO, " ", (int)BAR);


Base framework
##############

; -> @nfeske


New component API
=================

Each component has to provide an implementation of the 'Component' interface
as exemplified in the previous section.

Each component is a composition of a protection domain (PD session), a
memory budget (RAM session), and a CPU session, from which the initial thread
is created. These sessions form the _environment_ of the component, which is
represented by the 'Env' interface class (_base/env.h_). The environment is
provided to the component as argument to the 'Component::construct'
(_base/component.h_) function.

:deprecated global 'env()' accessor function:

  During the migration phase to the new API, the 'Genode::env()' is still
  available. But it ultimately vanish from the API.

Each component is equipped with an initial 'Entrypoint' (_base/entrypoint.h_)
that is accessible via 'Env::ep()'. Each entrypoint is able to respond to
both RPC requests and signals. The 'Component::construct' function is
executed in the context of the entrypoint. None of the entrypoint's RPC
objects or signal handlers will be called before returning from the
'Component::construct' function.

:deprecated _os/signal_rpc_member_:

  The former 'Signal_rpc_member' is superseded by the new 'Signal_handler'
  (_base/signal.h_).

  Signal-handling methods receive no longer a signal counter value as
  arguments as there haven't been any convincing use cases for this
  feature. In the contrary, it actually led to wrong design choices in the
  past where the rate of signals carried information (such as the progress
  of time) that should better be obtained via an explicit RPC call.

:deprecated connection constructors without 'Env' argument:

  To eliminate the reliance on the deprecated global 'env()', all
  connection objects have to take
  takes a reference to the component's environment as argument.
  The original constructors are marked as deprecated. Once we have
  completely abolished the use of the global 'env()', we will remove them.


Consolidation of core's SIGNAL, CAP, RM, and PD services
========================================================

With the new API, each component implicitly requires a session to core's CAP
service (to be able to handle RPC requests by the entrypoint) and a session to
the SIGNAL service (to dispatch signals by the entrypoint). Therefore, the
separation of these services serves no purpose any longer. To simplify the
API, the former SIGNAL, CAP, RM, and PD services are now integrated in the
PD service. This change has several benefits:

* It reduces the API complexity,
* It reduces the component-startup costs because only one session must
  be created instead of four.
* It reduces policy with respect to the dimensioning of the various
  session quotas.

In order to unify the API across all different base platforms, the PD
session interface contains no kernel-specific parts any longer. There
is now a dedicates sub interface called 'Native_pd' that accommodates
such needs. A capability to this kernel-specific interface can by
requested via the 'Pd_session::native_pd' accessor method. The kernel-specific
interfaces are named Nova_native_pd, Foc_native_pd, and Linux_native_pd.

:deprecated _cap_session/_:

  With the integration of CAP service into the PD service, the CAP session
  interface ceased to exist. However, there are still old-style components
  that manually create a 'Cap_connection' to be passed as argument to an
  'Rpc_entrypoint'. To avoid breaking those components, we keep a pseudo
  'Cap_connection' around. But the implementation does not actually create
  a session but merely returns the PD session interface of the component,
  which matches the argument type of the 'Rpc_entrypoint'.

:new _region maps_ replace former RM sessions:

  The functionality of the former RM sessions has moved to the region-map
  interface, which is an RPC interface but not a session.
  Each PD session contains 3 region maps, one for the entire virtual
  address space, one for the stack area (formerly called thread-context
  area), and one for the linker area. The new RM service is merely
  responsible for the provisioning of managed dataspaces but is no longer
  used by regular components.

  As a minor refinement, the 'Fault_type' enum values are now part of the
  'Region_map::State' struct.



New log-output facilities
=========================

Throughout Genode, we used to rely on C-style format strings for the output of
diagnostic information and for the assembly of strings. There are many
drawbacks of this approach such as the limitation of the printable types to
the built-in format-string specifiers, the lack of type safety, and the
mismatch between the implementation of the intuitive expectations by the API
users.

With the current release we introduce the new log-output facility _base/log.h_
that will ultimately replace the original set of convenience macros PDBG,
PWRN, PERR, PINF by C++ function templates using variadic template arguments.
The function templates are plainly called 'log', 'error', and 'warning'
residing in the 'Genode::' namespace. The replacement for 'PDBG' must be a
macro in order to encode the calling function name into the string. As of now,
this functionality is not yet covered by _base/log.h_.

The header _base/output.h_ contains the mechanics for extraction a textual
representation from values and object instances. It provides the abstract
'Output' interface to be implemented by a consumer of text.
Functions for generating output for different types are named 'print' and
take an 'Output &' as first argument. The second argument is a 'const &'
to the value to print. Overloads of the 'print' function for commonly
used basic types are readily provided. Furthermore, there is a function template
that is used if none of the type-specific overloads match. This function
template expects the argument to be an object with a 'print' method. In
contrast to a plain 'print' function overload, such a method is able
to incorporate private state into the output.

The component's execution environment provides an implementation of the
'Output' interface that targets a LOG session. This output back end is
offered to the component in the form of the 'log', 'warning', and 'error'
functions that accept an arbitrary number of arguments that are printed
in a concatenated fashion. Each messages is implicitly finalized with a
newline character.

:deprecated _base/printf.h_, _base/console.h_, and _base/snprintf.h_:

  The goal of the new output facilities is the complete removal of format
  strings from the Genode API. Hence, the listed headers should be
  avoided.


XML processing
==============

Since the first version, Genode's init component relied on a configuration in
an XML-like syntax. For a long time, however, we remained hesitant to make the
base system (core and the base API) inherently dependent on XML. For the most
part, this hesitance was founded on our observation that XML tends to be
disliked in systems-programmers circles. However, over the years, XML
organically became the predominant syntax for component configurations as well
as for the propagation of state between components. Whereas the syntactical
merits of XML are highly subjective and perhaps debatable, the beauty of using
XML within Genode lies in its consistent application. For example, it allows
us naturally to embed component configurations in another component's
configuration. Much of Genode's flexibility that we enjoy today can be
attributes this coherency. Granted, this argument would apply just as well to
alternatives such as JSON or s-expressions. But we have to take one choice and
stick to it.
While we found that XML satisfies our needs and actually never stands
in the way, the impact on the code complexity is negligibly. Our XML parsing
and generating utilities are in the order of 700 lines of code.

With this perspective, we take the deliberate decision to make XML mandatory
for even the lowest-level parts of the framework. For example, even the
dynamic linker obtains the policy for diagnostic output from an XML-formatted
configuration. Consequently, we moved the XML utilities to
_base/include/util/_.

To ease the use it the XML parsing utilities, we also added the accessors
'Xml_node::type' and 'Xml_attribute::name' that return 'Genode::String'
objects.

:changed constructor of 'Reporter':

  One prominent use of XML is the reporting of state information from
  components to a report service. Most components facilitate the
  'Genode::Reporter' for this job. Originally, the report name is used
  implicitly as the top-level XML node type of the report.  This is inconvenient
  if one component wants to generate various XML reports under various names
  (e.g., to steer consumers/clients slightly differently) but with the same XML
  node tree structure. To accommodate those needs, the 'Reporter' now takes XML
  node type and the report label as two distinct arguments.


Dataspace helpers
=================

The use of dataspaces, e.g., for setting up shared memory between components,
involves typical sequences of operations. The 'Attached_*_dataspace'
utilities located at _os/include/os/_ take care of these technicalities.
With the current release, we promote them to be part of the base API and
thereby can leverage those utilities even for the lowest-level
components and internally. On that account, the corresponding header
files were moved to _base/include/base/_.

:changed constructors of 'Attached_*_dataspace' utilities:

  Originally, the dataspace utilities relied on side effects via the
  'Genode::env()' accessor. To break away from this bad practice, the
  new versions have constructors that take all needed resources as explicit
  arguments. The original constructors are scheduled for removal.

The most common use case of 'Attached_rom_dataspace' is the consumption
of XML-formatted data. To accommodate this common pattern, we equipped
the 'Attached_rom_dataspace' with an accessor plainly named 'xml'.
It always returns a valid 'Xml_node' even in the event
where the dataspace is invalid or contains no XML. In such cases, the returned
XML node is '<empty/>'. This way, we spare the caller the handling of the
exceptions that may occur during the XML parsing.
Now a configuration attribute can be obtained as follows:

!Genode::Attached_rom_dataspace config(env, "config");
!...
!bool const verbose = config.xml().attribute_value("verbose", false);

:deprecated _os/config.h_:

  Since it has become so easy to consume XML ROM sessions, the role of the
  former 'Genode::config()' interface has become largely obsolete. In line
  with our goal to eliminate global side effects, the _os/config.h_ has
  become deprecated.


Thread API and CPU-session interface
====================================

The thread API and the CPU-session interface underwent a major revision.


CPU session interface
---------------------

:Assigning threads to a PD at their creation time:

  We replaced the former 'Pd_session::bind_thread' method by a
  PD-capability argument of the 'Cpu_session::create_thread' function, and
  removed the ancient thread-start protocol via 'Rm_session::add_client' and
  'Cpu_session::set_pager'. Threads are now bound to PDs at their creation
  time and implicitly paged according to the address space of the PD.

:New 'Cpu_session::Weight' type:

  The new type replaces a formerly used plain integer value to prevent the
  accidental mix-up of arguments.
  The enum definition of 'Cpu_session::DEFAULT_WEIGHT' moved to
  'Cpu_session::Weight::DEFAULT_WEIGHT'.

:Separation of platform-specific operations from generic CPU session:

  The CPU session interface has been unified across all platforms. The
  former differences are moved to respective "native-CPU" interfaces
  analogously to how the 'Native_pd' interface is separated from the
  'Pd_session' interface.

:Separation of thread operations from CPU session:

    The former CPU-session interface contained a number of operations
    that took a thread capability as first argument. Those thread-manipulation
    operations are now accessible as RPC interface on the thread capability
    directly.

    A noteworthy semantic change is the meaning of the former
    'exception_handler' RPC function, which used to define both the default
    exception handler or a thread-specific signal handler. Now, the
    'Cpu_session::exception_sigh' function defines the CPU-session-wide
    default handler whereas the 'Cpu_thread::exception_sigh' function
    defines the thread-specific one.


Thread API
----------

Most regular component no longer need to use the thread API directly.
Instead, the 'Entrypoint' (which is a thread) should be used whenever possible.

:removed details from _base/thread.h_:

  We moved the details about the stack allocation and organization from the
  public API to framework-internal headers and replaced the notion of
  "thread contexts" by "stacks" as this term is more intuitive.

:renamed and removed classes, new constructors:

  The former 'Thread<>' class template has been renamed to
  'Thread_deprecated'. Threads with the stack supplied as template argument
  should no longer be used. The stack size should always be passed as
  constructor argument.

  The former 'Thread_base' class is now called 'Thread'.

  The new Thread constructor that takes an 'Env &' as first argument.
  The original constructors are now marked as deprecated. For the
  common use case where the default 'Weight' and 'Affinity' are
  used, a shortcut is provided. In the long term, those two
  constructors should be the only ones to remain.

  A new 'name()' accessor returns the thread's name as 'Name'
  object as centrally defined via 'Cpu_session::Name'. It is meant to
  replace the old-fashioned 'name' method that takes a buffer and size
  as arguments.


Child management
================

The 'Child' class has been adapted to the changed core services and partially
redesigned to enable the implementation of single-threaded runtime
environments that virtualize the CPU, PD, and RAM services. It thereby has
become free from side effects. I.e., instead of implicitly using
'Genode::env()->rm_session()', it takes the reference to the local region map
as argument. Also, the handling of the dynamic linker via global variables is
gone. Now, the linker binary must be provided as constructor argument.


Stylistic changes
=================

:'Heap', 'Sliced_heap', 'Root_component':

  We added new constructors to these classes that take references, not
  pointers, as arguments. The old constructors will be removed with the
  next release.

:Naming of boolean getter methods:

  We already follow a convention about the naming of accessor methods (not
  using any get_ or set_ prefixes). However, we sometimes used an "is_" prefix
  for getter functions of boolean values, but not always. Examples are
  'Capability::valid()' and 'Weak_ptr::is_valid()'.

  In the name of the principle of least surprise, we introduced the convention
  to not use an "is_" prefix for such methods. We adjusted all occurrences
  within the Genode code base accordingly. To maintain API compatibility
  during the transitional phase, keep the original methods until the next
  release.

:Alleviating the need for manually constructed type lists:

  The 'GENODE_RPC_INTERFACE' macro of the RPC framework had a limitation
  with respect to the number of RPC functions per RPC interface. As a
  workaround for this limitation, large session interfaces had to manually
  define the type list of RPC functions out of nested type tuples. With the
  current release, we removed the limitation.


Removed and to-be-removed APIs
==============================

:removed _base/crt0.h_ and _base/elf.h_:

  Those headers are internally needed by the framework but contain no
  actual value at the API level. Therefore we removed them from the
  public API.

:removed _base/process.h_:

  The 'Process' class encapsulated the platform-specific steps to start
  a Genode component with a given ELF file. The original intention of
  placing this low-level mechanism into a dedicated class was to allow
  for different flavours it child-management policies. In practice, however,
  the 'Process' remained solely being used by the 'Genode::Child'. Since
  the core-interface changes of Section
  [Consolidation of core's SIGNAL, CAP, RM, and PD services]
  required us to rewrite the component-creation code anyway and we aspire to
  narrow the API, we took the chance make 'Process' private to the 'Child'.
  The rather ambiguous term "process", which we avoid in the context
  of Genode by speaking of "components" instead, is eliminated from the public
  API.

:discourage use of _util/arg_string.h_:

  The 'Arg_string' utilities are used to generate and parse session-argument
  strings. However, to make Genode more coherent and session arguments more
  flexible and robust, we plan to replace the current argument-string
  syntax with XML, eventually removing the argument-string support. Hence,
  we discourage the use of 'util/arg_string.h'.

:discourage use of _base/signal.h_:

  The introduction of the new 'Entrypoint' eliminates the need to manually
  create and use 'Signal_receiver'. Right now, we still rely on the original
  signal API as backend of the 'Entrypoint' but we will eventually remove
  the current notion of signal receivers. The narrower semantics of the
  'Entrypoint' will then allow for performance optimizations that are not
  possible with the traditional signal receivers. Therefore, we discourage
  the direct use it 'Signal_receiver'.


Low-level OS infrastructure
###########################

Enhanced GDB support on NOVA
============================

During the practical work with the GDB monitor (our Genode port of the GNU
'gdbserver' application) and our nightly automated execution of the
'gdb_monitor.run' test, it turned out that there are still situations which
GDB monitor cannot handle correctly. Since the error symptoms often occur only
sporadically and it is often not obvious if the cause of the error is located
in the Genode-specific adaptations of the gdbserver code or in the platform-
specific functionality of the Genode base system, a first step to improve the
stability of the debugger was to try to remove existing Genode-specific code
from the gdbserver codebase and to emulate the Linux-specific C interface
instead, which especially involved a GDB monitor-local implementation of the
'waitpid()' function. This interface is documented relatively well and in the
case of error there would be a better chance of comparing the GDB monitor-
internal execution sequence with a corresponding test case on the Linux version
of gdbserver.

The emulation of this interface is not trivial, though, because the behavior of
the Linux kernel often differs from the behavior of the Genode base components.
For example, when debugging a Linux program, a new thread created by the
debug target gets stopped automatically by the Linux kernel and the 'waitpid()'
function reports a SIGSTOP signal for the new thread and a SIGTRAP signal for
the creating thread to the gdbserver. This behavior does not match at all with
the design of the Genode base system, so it gets emulated in the GDB monitor
with the help of a software breakpoint on the first instruction of the new
thread and the artificial creation of the corresponding SIGSTOP and SIGTRAP
signal reports.

While implementing this mechanism in the
'Gdb_monitor::Cpu_thread_component::start()' method, it turned out that on the
NOVA platform on the creation of a so-called 'local thread' (a NOVA thread
which only responds to IPC and has no execution time of its own), the initial
instruction pointer passed to the function was always 0. So, changes in the
NOVA base system were necessary to get to know the correct start address
of the thread in order to set a breakpoint there. Another problem was found to
be that an attempt by GDB monitor to pause a thread of the debug target could
block for quite some time if the particular thread was currently blocking in a
NOVA syscall. In that case, the 'Cpu_thread::pause()' call returned only after
the particular thread got executed in userland again, because only then the
current register state of the thread could be transferred into userland for
retrieval by GDB. This problem got solved by an extension of the NOVA kernel,
which makes it possible to get the current register state of a to-be-paused
thread immediately most of the time.

Furthermore, the NOVA-specific changes for GDB make it possible for GDB to
modify register values and to debug 64-bit applications.

As reference, the 'ports/run/gdb_monitor.run' script demonstrates and tests a
selection of the features supported by GDB on Genode.


New support for the Rust programming language
=============================================

[https://www.rust-lang.org/ - Rust] is a systems programming language that
currently gains a lot of popularity. It eliminates entire classes of bugs by
enforcing memory safety. Unlike languages that rely on a garbage-collecting
runtime, compiled Rust programs are able to run on bare-metal hardware. This
makes Rust an attractive language for low-level system components.

The current Genode release introduces basic support for executing
Rust programs as Genode components. This support includes the
build-system integration, the configuration of the llvm-based Rust
compiler, and the port of the low-level language runtime. A simple example is
provided via the _libports/run/rust.run_ script and the accompanied code at
_libports/src/test/rust/_. The example runs on the x86 (32 and 64 bit) and
ARM architectures.

Thanks to Waylon Cude for bringing Rust to Genode!


Dynamic linker
==============

; XXX should we keep this section?

The dynamic linker will now check if the binary pointer is valid before
attempting to lookup a symbol. Shared objects with unresolved symbols and
missing dependencies, e.g. a library that references 'errno' but is not linked
against libc, will now produce an error message when they are loaded by the
dynamic linker instead of triggering a ominous page-fault.


New component for writing ROM modules to files
==============================================

The rom-to-file component at _repos/os/src/app/rom_to_file_ requests a ROM
session and writes the content of the ROM dataspace to a file of a file-system
session. It is able to respond to configuration and ROM-module updates. The
name of the ROM module must be specified via the 'rom' attribute of the
components '<config>' node:

! <config rom="pointer"/>

See _run/rom_to_file.run_ for an example.

Thanks to Johannes Schlatow for this contribution!


C runtime
=========

; -> @chelmuth

commit 93b82c14ac3cd39fda84f6cc61dfab019456cb60
Author: Emery Hemingway <emery@vfemail.net>
Date:   Fri Apr 15 14:19:51 2016 +0200

    libc: read sysctl info from /.sysctl/...
    
    Fixes #1931


libc_pipe plugin
~~~~~~~~~~~~~~~~

The new 'libc_pipe' plugin provides a more accurate implementation of pipes
(using a ring buffer) and replaces the existing 'libc_lock_pipe' plugin.


Device drivers
##############

In this release we did update several device drivers that are ported from
forgein OS'. In addition, we consoldiated all drivers in the dde_linux
repository by utilizing the modular lx_kit and made sure that each driver
is using the same Linux version now.


HDA Audio driver update
=======================

The audio driver was synced with version 5.9 of OpenBSD. In addition to
updating the contrib sources the driver now uses the new Component API
and will report the internal mixer state.

Reporting of the mixer state is enabled by adding the 'report_mixer'
attribute to the drivers configuration and setting its value to 'yes'.

The following snippets illustrates the format of the report:

!<mixer_state>
!  <mixer field="inputs.beep" value="108"/>
!  <mixer field="outputs.hp_sense" value="plugged"/>
!  <mixer field="outputs.master" value="128,128"/>
!  <mixer field="outputs.mic_sense" value="unplugged"/>
!  <mixer field="outputs.spkr_muters" value="hp,mic"/>
!</mixer_state>

The mixer state can expose other mixer fields as well, depending on the
used hardware. The naming scheme of the attributes intentionally matches
the naming scheme of OpenBSD's mixerctl(1) program.

In return, 'mixer' nodes may be used to configure the audio driver by
specifying it in the configuration, e.g.:

!<config report_mixer="yes">
!  <mixer field="outputs.master" value="255,255"/>
!</config>

will set the output volume to the highest possible value. Although it is
now also possible to update the configuration at run-time this should only
be done with care. Updating the configuration while the driver is playing
or recording may provoke audible artefacts. For now it is best to use the
mixer component to regulate the volume rather than adjusting the audio
driver directly.


Linux kit
=========

Over the years the way we handled our DDEs has changed. By now it became
clear that it is easier to manage ported drivers without having to rely an
generic API like dde_kit. Using Genode primitives directly enables us to
specially tailor each DDE to the driver in question. That being said,
when having four different drivers (intel_fb, lxip, usb and wifi) and each
has its own specially tailored DDE, the amount of redundant code is huge.
We created the lx_kit that enables us to share code across the drivers as
well as to provide specific pieces in each driver itself to address this
issue and eventually decrease the amount of redundant code.

This modular lx_kit seperates the required back end functionality of the
Linux emulation environment from the front end. Thereby each driver can
reuse generic parts and supply more suitable implementations by itself.
It is split into several layers whose structure is as follows:

The first layer in _repos/dde_linux/src/include/lx_emul_ contains those
header files that provide the structural definitions and function
declarations of the Linux API, e.g. _errno.h_ provides all error code
values. The second layer in _repos/dde_linux/src/include/lx_emul/impl_
contains the implementation of selected functions, e.g. _slab.h_
provides the implementation of 'kmalloc()'. The lx_kit back end API is
the third layer and provides the _Lx::Malloc_ interface
(_repos/dde_linux/src/include/lx_kit/malloc.h_) which is used to
implement 'kmalloc()'. There are several generic implementations of the
lx_kit interfaces that can be used by a driver.

A driver typically includes a 'lx_emul/impl/xyz.h' header once
directly in its lx_emul compilation unit. The lx_kit interface files
are only included in those compilation units that use or implement the
interface. If a driver wants to use a generic implementation it must
add the source file to its source file list. The generic
implementations are located in _repos/dde_linux/src/lx_kit/_.

The modular lx_kit still depends on the private _lx_emul.h_ header file
that is tailored to each driver. Since the lx_kit already contains much
of the declarations and definitions that were originally placed in
these private header files, those files can now ommit a large amount
of code.


Wifi driver update
==================

The wifi_drv was updated to Linux version 4.4.3 and thereby adds support for
Intel wireless card 8xxx series. In order to ease debugging the driver now
enables its debugging messages when the 'verbose' attribute in its 'config'
node is set to 'yes'.


USB driver update
=================

The USB driver was updated to Linux version 4.4.3 and like the other drivers
incorporates the modular lx_kit. The new driver exposed problems with the
EHCI controller on older systems, namely the Thinkpad X201. Using the new USB
driver on this machine would freeze the system when 'USB legacy Support' is
enabled in the BIOS. The fix is to apply the USB hand-off quirk, that informs
the BIOS that the OS wants to drive the USB host-controller and waits until
the BIOS has acknowledged the request. Unfortunatly, applying this quirk
produces problems on certain xHCI host-controllers when using the IOMMU. In
this case the driver tried to perform the hand-off request but got stuck while
writing to the PCI config space. After about 20 seconds we saw a DMA fault and
the initialization of the USB driver went on. Presumably at this point the BIOS
tries to access certain memory regions that by now are protected by the IOMMU.
When using the IOMMU, we already take precautions, i.e., we look at the RMRR
regions and instruct the kernel to configured the IOMMU for specific devices
accordingly. We looked at the ACPI RMRR region of the USB on the machine in
question and could confirm our suspicion: the registered USB RMRR region is
indeed too small. For all we know that sounds like a bug in BIOS or rather
ACPI tables. To accomodate systems that nonetheless need the hand-off quirk
and the user wants to use the IOMMU, we added the handling of a 'bios_handoff'
attribute to the USB driver configuration. When set to 'no' the driver will not
perform any hand-off request. The default setting is 'yes'. If you experience
any issues with the new USB driver, disabling the hand-off is advised.

While updating the driver a regression on the Raspberry Pi was introduced.
USB devices that use IRQ endpoints, e.g. USB HID devices, do not work
reliably. This issue is still unresolved and dealing with it is post-poned
until after the release.

Furthermore, the USB session used for implementing native USB device drivers
propagates an EP stall error to the client and clears the stall condition by
resetting the EP now.


Intel graphics driver update
============================

The Intel graphics driver introduced in Genode release 15.11 was updated to
Linux version 4.4.3. The most prominent, functional improvement is support for
Intel Skylake graphics cards.
Internally, we slimmed the code parts used from the Linux kernel by resigning
the ancient framebuffer and framebuffer console layer. The new driver only uses
the more modern DRM layer of the Linux kernel. As a side effect all formerly
available heuristics that were applied at initialization time, or whenever a
display got connected are not part of the driver anymore. Now, the driver only
reports any state changes like additional available displays via its report
session. On the other hand it always updates the graphics configuration whenever
its config ROM module changes.
To automatically control the graphics driver during display connection changes
an example component named intel_fb_controller is now available in:
_repos/dde_linux/src/test/framebuffer/intel_. This component reacts on report
changes of the Intel graphics driver and configures it in a way that all
available displays are showing one and the same framebuffer with their maximum
resolution. Thereby displays with a minor resolution show the upper left corner
of the whole framebuffer.


Enhanced ACPI support
=====================

Modern PCs provide via the Advance Configuration and Power Interface (ACPI)
Specification an enormous amount of ways to monitor and to
configure the system. In Genode we have already since release 12.02 a basic
ACPI driver, which is mainly used to look up low level data via some clever
pattern matching heuristic. These information, like interrupt remapping, are
sufficient to bootstrap and setup the Genode user-level part of the system. We
wanted to go beyond this feature set and wanted to leverage further - dynamic -
aspects of ACPI like system state changes of batteries in notebooks or lid
status.

The ACPI Component Architecture project ACPICA - www.acpica.org - develops and
maintains a operating system independent reference implementation of ACPI,
which can be used by operating systems like Genode to utilize the full
functionality of modern PCs. So, we took the reference implementation of
ACPICA and ported it to Genode. The port itself was relative straight forward
and really a pleasure. The interfaces and abstractions to the operating system
are well choosen by the ACPICA project, clearly documented and a porter is well
guided by extensive explanatory documentation.

The port is hosted in the libports repository as a standalone Genode library,
without any additionally dependencies (beside Genode base library). To utilize
and experiment with the ported library we started to develop a Genode
application, called app/acpica, which utilize the library. We experimented and
managed to enable the ACPI lid, ACPI embedded controller (e.g. Fn keys),
ACPI AC adapter, ACPI smart battery subsystem and ACPI fixed events,
e.g. powerbutton, on some modern Intel Skylake notebook and partly also on
some older Lenovo machines, e.g. X201. Additionally we added support to reset
and poweroff machines via ACPI.

ACPI state changes will be reported by the acpica application by setting the
config attribute to "yes".

!<start name="acpica">
!  <config reset="yes" poweroff="yes" report="yes"/>
!  ...

Whenever such a state change is detected, the application will generate the
appropriate Genode report named 'acpi_lid', 'acpi_ac', 'acpi_battery',
'acpi_ec' or 'acpi_fixed'. The more detailed content of the reports is
documented in the README of app/acpica or can be manually experienced by
trying out the acpica run script in the libports repository.

In order to reset or to poweroff machines, the config attribute 'reset'
respectively 'poweroff' must be set to 'yes', as shown before. If one of both
attributes is configured, app/acpica will open a Genode ROM called 'system'
and monitor changes to that ROM. The ROM must be XML in the following form:

!<system state="..."/>

If the state attribute is set to 'reset' or to 'poweroff', app/acpica will
try to reset respectively poweroff the machine immediately. The operation may
fail, if the hardware resources are owned by some other components in the
Genode system. E.g. on some machines we tested on, the reset operation fails
because the required I/O ports are owned and are used by the x86 platform
driver. For such cases we extended the platform driver by an additionally
config parameter "system" which must be set to "yes", e.g.:

!<start name="platform_drv" >
!  ...
!  <config acpi="yes" system="yes">
!  ...

The platform driver will than also open and monitor a Genode ROM of name
"system" and will react upon a state change to 'reset'. If the platform driver
owns the required I/O ports it will trigger the ACPI reset.

In the current state, we use still our old simple ACPI driver to detect
basic necessary information for the x86 platform driver. The ACPI driver
reports all findings in form of a Genode report which is provided as Genode
ROM to the platform driver. The acpica application than later on,
after the platform driver announces its service, take over the ACPI
functionality of our old ACPI driver and takes care of all dynamic ACPI events.

It first looks a bit cumbersome, however the reasons are twofold. First,
we wanted to start to experiment with the acpica library without putting our
ACPI driver at danger. Second, we wanted to see whereto the complexity of the
additionally ACPI features takes us. If one is using sloccount, or cloc, as
complexity measure and applies the tool to the respectively folders, the
following line of numbers show up:

repos/os/src/driver/acpi/      ~1000

contrib/acpica-<hash>/         ~120000       ACPICA library
repos/libports/src/lib/acpica/ ~600          Genode specific ACPICA libary support code
repos/libports/src/app/acpica/ ~1000         application using the ACPICA Genode port

Of course, the numbers are inaccurate and the comparison is unfair, since
we do not take into account which files of the acpica library are actually in
use. Furthermore we can get more functionality with the acpica library, which
we never could achieve with our own basic ACPI driver implementation. However,
the point here to made is, that we have to add much complexity to get a full
ACPI capable system and that solely a small amount of the complexity actually
is really required to drive a operating system like Genode.

Generalized SDHCI driver
========================

The SDHCD driver was originally creates for the Raspberry Pi. However, the
same host controller is used also in other platforms, in particular Xilinx
Zynq. Hence, the existing driver was generalized to become usable on such
platforms. Thanks to Timo Wischer for this contribution.


Libraries and applications
##########################

LxIP update
===========

LxIP is the port of the Linux TCP/IP stack as a library on Genode.
Along with the work described in Section [Linux kit], LxIP was updated to
Linux version 4.4.3 and uses the lx_kit now.


Qemu USB
========

; XXX should we keep this section or is the level of detail too much?

The QEMU USB library handles EP stalls now. In particular, this fix
enables the usage of USB devices in VirtualBox that do not support certain
SCSI commands, e.g. READ_FORMAT_CAPACITY, and will stall if they receive
such a command. Windows guests typically use the afor mentioned command to
check if the USB storage device in question is in fact an USB floppy drive.


Platforms
#########

Generalization of platform-specific headers
===========================================

In anticipation of the planned binary compatibility of Genode components
across different kernels, we unified most parts of Genode's base API and
largely removed the dependency on platform-specific types. The most profound
change is the interface of the IPC library, which used to depend on
platform-specific message-buffer layouts.
Besides unifying the message buffer classes across all platforms, we
reconsidered the roles of the IPC-library classes such as 'Ipc_marhsaller',
'Ipc_server', and 'Ipc_client'. This led to several further simplifications in
the server-loop implementations, which makes the flow of control and
information much more obvious, yet is also more flexible. I.e., on NOVA, we
don't even have the notion of reply-and-wait. Now, we are no longer forced to
pretend otherwise.


NOVA microhypervisor
====================

; -> @alexab

commit dccad4c526b7ea93f6a5b1d79138423518a2924c
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Thu Apr 28 13:38:21 2016 +0200

    nova: kernel support for more than 4096 processes
    
    Fixes #1951

commit 1622f53dd815804a9a64b0cd89a2f85c8427c9e0
Author: Alexander Boettcher <alexander.boettcher@genode-labs.com>
Date:   Thu May 12 12:53:17 2016 +0200

    nova: support fixed ACPI event delivery by kernel
    
    Issue #1962


Execution on bare hardware (base-hw)
====================================

For running Genode scenarios on our custom kernel (base-hw), two hardware
timers are needed. One timer is used by the kernel as the basis for the
preemptive scheduling. The other timer is used by the user-level timer
driver as the timing source for user-level components.

On NOVA, we gathered good experiences with using the kernel's scheduling
timer as the basis for the user-level timer. Eliminating the need for
a real timer device driver (like the PIT) reduces the overall complexity.
The interrupt load becomes lower without the userland triggering timer
interrupts. And since the kernel uses CPU-core-local timers (i.e. the
local APIC timer on x86) as opposed to a global timer in the userland,
expensive cross-CPU-communication is avoided.

With the current release, we applied the lessons learned to our base-hw
kernel. As a further motivation, the removal of the dependency on a
timer device clears the way to run multiple Genode instances on top of
the Muen separation kernel.

The timeout feature has the form of a new 'timeout' system call that binds
a signal context to a timeout. Hence, timeouts are delivered asynchronously,
like interrupts, to the user-level timer service. The actual time can be
requested via the 'timeout_age_us' system call, which returns the time
since the last timeout was installed.


Linux
=====

; -> @chelmuth

commit 14f1ac497efc9f4f1fa4d92f8a720e9a0be5403e
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Fri Apr 8 18:24:15 2016 +0200

    linux: improve exception-signal handling
    
    First, we use an alternate stack for signal handling now. The stack is
    shared among all threads of the component, which is okay as we only
    handle exceptions with log output and pass on to the default handler
    (that terminates the execution). The primary motivation for the
    alternate stack is the detection of SIGSEGV due to stack overflows.
    
    Also, hybrid components now handle exception signals by logging and the
    support for multi-threaded applications was improved.
    
    Fixes #1935


Tools and build system
######################

Usability improvements of the ports tools
=========================================

The ports tool set introduces in
[http://genode.org/documentation/release-notes/14.05#Management_of_ported_3rd-party_source_code - Genode 14.05]
has become an integral part of the workflow for Genode developers.
With the current release, we improve the usability of the _prepare_port_ tool
in two respects. First, the tool now accept a list of ports instead of
merely a single argument. This alleviates the need to manually re-execute
the tool with different arguments. Second, if the build system encounters
a missing port it no longer backs out immediately but collects all the
(potentially more than one) missing ports that are required for the build.
It then presents the user with a ready-to-use command to install all
missing ports at once, which greatly improves the experience of working with
sophisticated system scenarios. For example, when attempting to execute
the _virtualbox.run_ script with a freshly cloned Genode source tree,
the build system produces the following error message:

!Error: Ports not prepared or outdated:
!  dde_linux libc libiconv nova qemu-usb stdcxx virtualbox x86emu
!
!You can prepare respectively update them as follows:
!  .../prepare_port dde_linux libc libiconv nova qemu-usb stdcxx virtualbox x86emu

Additionally, one may state the number of ports that
shall be prepared in parallel at a max by using the -j parameter. If -j
is not set by the user, the tool acts as with -j1.

Since the _prepare_ports_ tool has completely replaced the former
"make prepare" mechanism, we finally removed the last traces of the old
mechanism in the form of the makefiles present in the respective source-code
repositories.


Updated tool chain
==================

; -> @chelmuth

We enabled the '__cxa_demangle()' function in our tool chain to be able to
print user-readable names of uncaught exceptions.

XXX tool chain update required
XXX added RISC-V
XXX GDB x86_64


Removal of stale features
#########################

We originally added chroot support to the Linux version of Genode to
accommodate the use of Genode as middleware on Linux. We enabled the
configuration of custom UIDs, GIDs, and chroot paths for components started by
init. However, apart from a brief period of time when we experimented with
the idea, it is no longer pursued. Now, with our aspiration to attain binary
compatibility across kernels, we removed the Linux-specific chroot support.
